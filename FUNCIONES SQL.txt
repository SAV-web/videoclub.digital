| routine_name                              | routine_type | data_type        |
| ----------------------------------------- | ------------ | ---------------- |
| get_actor_suggestions                     | FUNCTION     | text             |
| get_country_suggestions                   | FUNCTION     | text             |
| get_director_suggestions                  | FUNCTION     | text             |
| get_genre_suggestions                     | FUNCTION     | text             |
| get_search_suggestions                    | FUNCTION     | record           |
| gin_extract_query_trgm                    | FUNCTION     | internal         |
| gin_extract_value_trgm                    | FUNCTION     | internal         |
| gin_trgm_consistent                       | FUNCTION     | boolean          |
| gin_trgm_triconsistent                    | FUNCTION     | "char"           |
| gtrgm_compress                            | FUNCTION     | internal         |
| gtrgm_consistent                          | FUNCTION     | boolean          |
| gtrgm_decompress                          | FUNCTION     | internal         |
| gtrgm_distance                            | FUNCTION     | double precision |
| gtrgm_in                                  | FUNCTION     | USER-DEFINED     |
| gtrgm_options                             | FUNCTION     | void             |
| gtrgm_out                                 | FUNCTION     | cstring          |
| gtrgm_penalty                             | FUNCTION     | internal         |
| gtrgm_picksplit                           | FUNCTION     | internal         |
| gtrgm_same                                | FUNCTION     | internal         |
| gtrgm_union                               | FUNCTION     | USER-DEFINED     |
| process_staging_data                      | FUNCTION     | void             |
| search_and_count                          | FUNCTION     | record           |
| set_limit                                 | FUNCTION     | real             |
| show_limit                                | FUNCTION     | real             |
| show_trgm                                 | FUNCTION     | ARRAY            |
| similarity                                | FUNCTION     | real             |
| similarity_dist                           | FUNCTION     | real             |
| similarity_op                             | FUNCTION     | boolean          |
| strict_word_similarity                    | FUNCTION     | real             |
| strict_word_similarity_commutator_op      | FUNCTION     | boolean          |
| strict_word_similarity_dist_commutator_op | FUNCTION     | real             |
| strict_word_similarity_dist_op            | FUNCTION     | real             |
| strict_word_similarity_op                 | FUNCTION     | boolean          |
| to_integer_safe                           | FUNCTION     | integer          |
| to_real_safe                              | FUNCTION     | real             |
| unaccent                                  | FUNCTION     | text             |
| unaccent                                  | FUNCTION     | text             |
| unaccent_immutable                        | FUNCTION     | text             |
| unaccent_init                             | FUNCTION     | internal         |
| unaccent_lexize                           | FUNCTION     | internal         |
| word_similarity                           | FUNCTION     | real             |
| word_similarity_commutator_op             | FUNCTION     | boolean          |
| word_similarity_dist_commutator_op        | FUNCTION     | real             |
| word_similarity_dist_op                   | FUNCTION     | real             |
| word_similarity_op                        | FUNCTION     | boolean          |



-- Creamos o reemplazamos la función con la nueva firma y optimizaciones.
-- ✨ CORRECCIÓN: Se elimina la función existente antes de crear la nueva con una firma de retorno diferente.
DROP FUNCTION IF EXISTS public.search_and_count(text, text, text, text, text, text, text, text, text, text[], text[], integer, integer);

CREATE OR REPLACE FUNCTION public.search_and_count(
    search_term text, 
    p_genre_name text, 
    p_year text, 
    p_country_name text, 
    p_director_name text, 
    p_actor_name text, 
    p_media_type text, 
    p_selection text, 
    p_sort text,
    p_excluded_genres text[],
    p_excluded_countries text[],
    p_limit integer,
    p_offset integer
)
-- ✨ MEJORA: La firma de la tabla devuelta ahora incluye los nuevos campos.
RETURNS TABLE(
    id bigint, title text, year integer, year_end text, type text, genres text, 
    directors text, actors text, country text, country_code text, minutes integer, 
    image text, fa_id text, fa_rating real, fa_votes integer, imdb_id text, 
    imdb_rating real, imdb_votes integer, synopsis text, thumbhash_st text, 
    critic text, last_synced_at timestamptz, episodes integer, wikipedia text, total_count bigint
)
-- ✨ MEJORA: Marcamos la función como STABLE y PARALLEL SAFE.
LANGUAGE sql STABLE PARALLEL SAFE
AS $function$

-- Usamos una Expresión de Tabla Común (CTE) para mantener la lógica limpia.
WITH filtered_and_paginated_movies AS (
    -- Esta subconsulta primero filtra todos los IDs de las películas que cumplen los criterios
    -- y luego los ordena y pagina. Es la parte más intensiva de la consulta.
    SELECT 
        m.id,
        -- ✨ MEJORA CLAVE: Calculamos el conteo total una sola vez usando una función de ventana.
        COUNT(*) OVER() AS total_count_unpaginated
    FROM movies m
    WHERE
        -- La lógica de filtrado es la misma que la tuya original, que es robusta y correcta.
        (search_term IS NULL OR search_term = '' OR public.unaccent_immutable(m.title) ILIKE '%' || public.unaccent_immutable(search_term) || '%')
        AND (
            p_year IS NULL 
            OR (
                p_year LIKE '%-%' AND m.year BETWEEN (split_part(p_year, '-', 1)::int) AND (split_part(p_year, '-', 2)::int)
            )
            OR (
                p_year NOT LIKE '%-%' AND m.year = p_year::int
            )
        )
        AND (p_media_type IS NULL OR p_media_type = 'all'
            OR (p_media_type = 'movies' AND (m.type IS NULL OR m.type IN ('D', 'A')))
            OR (p_media_type = 'series' AND m.type ILIKE 'S%')
        )
        AND (p_country_name IS NULL OR m.country_id = (SELECT c.id FROM countries c WHERE c.name = p_country_name))
        AND (p_genre_name IS NULL OR EXISTS (SELECT 1 FROM movie_genres mg JOIN genres g ON mg.genre_id = g.id WHERE mg.movie_id = m.id AND g.name = p_genre_name))
        AND (p_director_name IS NULL OR EXISTS (SELECT 1 FROM movie_directors md JOIN directors d ON md.director_id = d.id WHERE md.movie_id = m.id AND d.name = p_director_name))
        AND (p_actor_name IS NULL OR EXISTS (SELECT 1 FROM movie_actors ma JOIN actors a ON ma.actor_id = a.id WHERE ma.movie_id = m.id AND a.name = p_actor_name))
        AND (p_selection IS NULL OR EXISTS (SELECT 1 FROM movie_collections mc JOIN collections coll ON mc.collection_id = coll.id WHERE mc.movie_id = m.id AND coll.code = p_selection))
        -- ✨ NUEVA CONDICIÓN: La película NO debe tener NINGUNO de los géneros excluidos.
        AND (p_excluded_genres IS NULL OR NOT EXISTS (
            SELECT 1 FROM movie_genres mg
            JOIN genres g ON mg.genre_id = g.id
            WHERE mg.movie_id = m.id AND g.name = ANY(p_excluded_genres)
        ))
        AND (p_excluded_countries IS NULL OR array_length(p_excluded_countries, 1) IS NULL OR m.country_id NOT IN (
            SELECT c.id
            FROM countries c
            WHERE c.name = ANY(p_excluded_countries)
        ))
    ORDER BY
        -- La ordenación se hace ANTES de la paginación para obtener el conjunto correcto.
        CASE WHEN split_part(p_sort, ',', 1) = 'id' AND split_part(p_sort, ',', 2) = 'asc' THEN m.id END ASC,
        CASE WHEN split_part(p_sort, ',', 1) = 'id' AND split_part(p_sort, ',', 2) = 'desc' THEN m.id END DESC,
        CASE WHEN split_part(p_sort, ',', 1) = 'year' AND split_part(p_sort, ',', 2) = 'asc' THEN m.year END ASC,
        CASE WHEN split_part(p_sort, ',', 1) = 'year' AND split_part(p_sort, ',', 2) = 'desc' THEN m.year END DESC,
        CASE WHEN split_part(p_sort, ',', 1) = 'fa_rating' AND split_part(p_sort, ',', 2) = 'desc' THEN m.fa_rating END DESC NULLS LAST,
        CASE WHEN split_part(p_sort, ',', 1) = 'imdb_rating' AND split_part(p_sort, ',', 2) = 'desc' THEN m.imdb_rating END DESC NULLS LAST,
        CASE WHEN split_part(p_sort, ',', 1) = 'fa_votes' AND split_part(p_sort, ',', 2) = 'desc' THEN m.fa_votes END DESC NULLS LAST,
        CASE WHEN split_part(p_sort, ',', 1) = 'imdb_votes' AND split_part(p_sort, ',', 2) = 'desc' THEN m.imdb_votes END DESC NULLS LAST,
        m.id ASC -- Orden secundario para consistencia
    LIMIT p_limit
    OFFSET p_offset
)
-- Ahora que tenemos solo los IDs de la página actual, hacemos los JOINs y la agregación
-- para obtener los datos completos. Esto es mucho más eficiente que hacer los JOINs a toda la tabla.
SELECT
    m.id, m.title, m.year, m.year_end, m.type,
    STRING_AGG(DISTINCT g.name, ', ') AS genres,
    STRING_AGG(DISTINCT d.name, ', ') AS directors,
    STRING_AGG(DISTINCT a.name, ', ') AS actors,
    c.name AS country, c.code AS country_code,
    m.minutes, m.image, m.fa_id, m.fa_rating, m.fa_votes, m.imdb_id, m.imdb_rating, m.imdb_votes, m.synopsis, m.thumbhash_st,
    m.critic, m.last_synced_at,
    -- ✨ AÑADIDO: Devolvemos los nuevos campos.
    m.episodes,
    m.wikipedia,
    -- Seleccionamos el conteo total que ya calculamos. Usamos MAX() porque es el mismo valor para todas las filas.
    MAX(fpm.total_count_unpaginated) AS total_count
FROM movies m
JOIN filtered_and_paginated_movies fpm ON m.id = fpm.id
LEFT JOIN countries c ON m.country_id = c.id
LEFT JOIN movie_genres mg ON m.id = mg.movie_id
LEFT JOIN genres g ON mg.genre_id = g.id
LEFT JOIN movie_directors md ON m.id = md.movie_id
LEFT JOIN directors d ON md.director_id = d.id
LEFT JOIN movie_actors ma ON m.id = ma.movie_id
LEFT JOIN actors a ON ma.actor_id = a.id
GROUP BY m.id, c.id
ORDER BY
    -- La ordenación final debe coincidir con la de la subconsulta para mantener el orden.
    CASE WHEN split_part(p_sort, ',', 1) = 'id' AND split_part(p_sort, ',', 2) = 'asc' THEN m.id END ASC,
    CASE WHEN split_part(p_sort, ',', 1) = 'id' AND split_part(p_sort, ',', 2) = 'desc' THEN m.id END DESC,
    CASE WHEN split_part(p_sort, ',', 1) = 'year' AND split_part(p_sort, ',', 2) = 'asc' THEN m.year END ASC,
    CASE WHEN split_part(p_sort, ',', 1) = 'year' AND split_part(p_sort, ',', 2) = 'desc' THEN m.year END DESC,
    CASE WHEN split_part(p_sort, ',', 1) = 'fa_rating' AND split_part(p_sort, ',', 2) = 'desc' THEN m.fa_rating END DESC NULLS LAST,
    CASE WHEN split_part(p_sort, ',', 1) = 'imdb_rating' AND split_part(p_sort, ',', 2) = 'desc' THEN m.imdb_rating END DESC NULLS LAST,
    CASE WHEN split_part(p_sort, ',', 1) = 'fa_votes' AND split_part(p_sort, ',', 2) = 'desc' THEN m.fa_votes END DESC NULLS LAST,
    CASE WHEN split_part(p_sort, ',', 1) = 'imdb_votes' AND split_part(p_sort, ',', 2) = 'desc' THEN m.imdb_votes END DESC NULLS LAST,
    m.id ASC;

$function$;
 


-- =================================================================
-- FUNCIONES AUXILIARES (SUGERENCIAS Y CONVERSIÓN SEGURA)
-- =================================================================

-- ✨ CORRECCIÓN: Se restaura la lógica original con JOIN y ordenación por popularidad.
CREATE OR REPLACE FUNCTION public.get_actor_suggestions(search_term text)
 RETURNS TABLE(suggestion text)
 LANGUAGE plpgsql STABLE PARALLEL SAFE
AS $function$
BEGIN
    RETURN QUERY
    SELECT a.name
    FROM actors a
    JOIN movie_actors ma ON a.id = ma.actor_id
    WHERE public.unaccent_immutable(a.name) ILIKE '%' || public.unaccent_immutable(search_term) || '%'
    GROUP BY a.name
    ORDER BY COUNT(ma.movie_id) DESC
    LIMIT 10;
END;
$function$;

-- ✨ CORRECCIÓN: Se restaura la lógica original con JOIN y ordenación por popularidad.
CREATE OR REPLACE FUNCTION public.get_director_suggestions(search_term text)
 RETURNS TABLE(suggestion text)
 LANGUAGE plpgsql STABLE PARALLEL SAFE
AS $function$
BEGIN
    RETURN QUERY
    SELECT d.name
    FROM directors d
    JOIN movie_directors md ON d.id = md.director_id
    WHERE public.unaccent_immutable(d.name) ILIKE '%' || public.unaccent_immutable(search_term) || '%'
    GROUP BY d.name
    ORDER BY COUNT(md.movie_id) DESC
    LIMIT 10;
END;
$function$;


CREATE OR REPLACE FUNCTION public.get_genre_suggestions(search_term text)
RETURNS TABLE(suggestion text) LANGUAGE sql STABLE PARALLEL SAFE AS $$
    SELECT name FROM public.genres
    WHERE similarity(name, search_term) > 0.2
    ORDER BY similarity(name, search_term) DESC
    LIMIT 5;
$$;

CREATE OR REPLACE FUNCTION public.get_country_suggestions(search_term text)
RETURNS TABLE(suggestion text) LANGUAGE sql STABLE PARALLEL SAFE AS $$
    SELECT name FROM public.countries
    WHERE similarity(name, search_term) > 0.2
    ORDER BY similarity(name, search_term) DESC
    LIMIT 5;
$$;


-- Función para convertir texto a INTEGER de forma segura
CREATE OR REPLACE FUNCTION public.to_integer_safe(v_input TEXT)
RETURNS INTEGER AS $$
BEGIN
    -- Intenta convertir el texto de entrada a un número entero.
    RETURN v_input::INTEGER;
EXCEPTION 
    -- Si ocurre cualquier error durante la conversión (ej. el texto es 'N/A'),
    -- en lugar de detenerse, captura la excepción y devuelve NULL.
    WHEN OTHERS THEN
        RETURN NULL;
END;
$$ LANGUAGE plpgsql;



-- Función para convertir texto a REAL (número con decimales) de forma segura
CREATE OR REPLACE FUNCTION public.to_real_safe(v_input TEXT)
RETURNS REAL AS $$
BEGIN
    -- Intenta convertir el texto de entrada a un número real.
    RETURN v_input::REAL;
EXCEPTION 
    -- Si ocurre cualquier error, captura la excepción y devuelve NULL.
    WHEN OTHERS THEN
        RETURN NULL;
END;
$$ LANGUAGE plpgsql;



-- =================================================================
-- SCRIPT COMPLETO DE OPTIMIZACIÓN DE ÍNDICES (VERSIÓN FINAL)
-- =================================================================

-- PASO 1: Activar extensiones
CREATE EXTENSION IF NOT EXISTS unaccent;
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- PASO 2: Crear la función "wrapper" inmutable para unaccent
CREATE OR REPLACE FUNCTION public.unaccent_immutable(text)
RETURNS text AS $$
    SELECT public.unaccent('public.unaccent', $1);
$$ LANGUAGE sql IMMUTABLE;

-- PASO 3: Crear todos los índices necesarios
CREATE INDEX IF NOT EXISTS movies_country_id_idx ON public.movies(country_id);
CREATE INDEX IF NOT EXISTS movie_genres_movie_id_idx ON public.movie_genres(movie_id);
CREATE INDEX IF NOT EXISTS movie_directors_movie_id_idx ON public.movie_directors(movie_id);
CREATE INDEX IF NOT EXISTS movie_directors_director_id_idx ON public.movie_directors(director_id);
CREATE INDEX IF NOT EXISTS movie_actors_movie_id_idx ON public.movie_actors(movie_id);
CREATE INDEX IF NOT EXISTS movie_actors_actor_id_idx ON public.movie_actors(actor_id);
CREATE INDEX IF NOT EXISTS movie_collections_movie_id_idx ON public.movie_collections(movie_id);
CREATE INDEX IF NOT EXISTS movie_collections_collection_id_idx ON public.movie_collections(collection_id);
CREATE INDEX IF NOT EXISTS genres_name_idx ON public.genres(name);
CREATE INDEX IF NOT EXISTS directors_name_idx ON public.directors(name);
CREATE INDEX IF NOT EXISTS actors_name_idx ON public.actors(name);
CREATE INDEX IF NOT EXISTS countries_name_idx ON public.countries(name);
CREATE INDEX IF NOT EXISTS collections_code_idx ON public.collections(code);
CREATE INDEX IF NOT EXISTS movies_year_idx ON public.movies(year);
CREATE INDEX IF NOT EXISTS movies_fa_rating_idx ON public.movies(fa_rating);
CREATE INDEX IF NOT EXISTS movies_imdb_rating_idx ON public.movies(imdb_rating);
CREATE INDEX IF NOT EXISTS movies_fa_votes_idx ON public.movies(fa_votes);
CREATE INDEX IF NOT EXISTS movies_imdb_votes_idx ON public.movies(imdb_votes);
CREATE INDEX IF NOT EXISTS movies_title_unaccent_trgm_idx ON public.movies USING gin (public.unaccent_immutable(title) gin_trgm_ops); 



-- =================================================================
-- PASO ADICIONAL: Añadir columnas episodes y wikipedia
-- =================================================================
ALTER TABLE public.movies ADD COLUMN IF NOT EXISTS episodes INTEGER;
ALTER TABLE public.movies ADD COLUMN IF NOT EXISTS wikipedia TEXT;


CREATE OR REPLACE FUNCTION public.process_staging_data()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    sync_timestamp TIMESTAMP WITH TIME ZONE := NOW();
    affected_movie_ids INT[];
BEGIN

    -- FASE 0: POBLAR TABLAS DE CATÁLOGO
    -- ----------------------------------------------------------------
    INSERT INTO public.genres (name)
    SELECT DISTINCT TRIM(g.name)
    FROM public.movies_staging, UNNEST(STRING_TO_ARRAY(genre, ',')) AS g(name)
    WHERE genre IS NOT NULL AND TRIM(genre) <> ''
    ON CONFLICT (name) DO NOTHING;

    INSERT INTO public.directors (name)
    SELECT DISTINCT TRIM(d.name)
    FROM public.movies_staging, UNNEST(STRING_TO_ARRAY(directors, ',')) AS d(name)
    WHERE directors IS NOT NULL AND TRIM(directors) <> ''
    ON CONFLICT (name) DO NOTHING;

    INSERT INTO public.actors (name)
    SELECT DISTINCT TRIM(a.name)
    FROM public.movies_staging, UNNEST(STRING_TO_ARRAY(actors, ',')) AS a(name)
    WHERE actors IS NOT NULL AND TRIM(actors) <> '' AND actors <> '(A)'
    ON CONFLICT (name) DO NOTHING;

    -- ✨ CORRECCIÓN CLAVE: Agrupamos por el código de país final para manejar alias.
    INSERT INTO public.countries (name, code)
    SELECT
        MIN(name) as name, -- Elegimos un nombre canónico (el primero alfabéticamente)
        code
    FROM (
        -- Primero, mapeamos cada nombre de país a su código
        SELECT DISTINCT
            TRIM(country) as name,
            CASE TRIM(country)
                WHEN 'EEUU' THEN 'us' WHEN 'Nueva Zelanda' THEN 'nz' WHEN 'Italia' THEN 'it' WHEN 'UK' THEN 'gb' WHEN 'Francia' THEN 'fr' WHEN 'Brasil' THEN 'br'
                WHEN 'Japón' THEN 'jp' WHEN 'España' THEN 'es' WHEN 'Corea del Sur' THEN 'kr' WHEN 'Australia' THEN 'au' WHEN 'Argentina' THEN 'ar'
                WHEN 'Sudáfrica' THEN 'za' WHEN 'Alemania' THEN 'de' WHEN 'Irlanda' THEN 'ie' WHEN 'México' THEN 'mx' WHEN 'Dinamarca' THEN 'dk'
                WHEN 'Suecia' THEN 'se' WHEN 'Canadá' THEN 'ca' WHEN 'Taiwán' THEN 'tw' WHEN 'Bélgica' THEN 'be' WHEN 'Hong Kong' THEN 'hk'
                WHEN 'Austria' THEN 'at' WHEN 'Irán' THEN 'ir' WHEN 'India' THEN 'in' WHEN 'Líbano' THEN 'lb' WHEN 'Grecia' THEN 'gr'
                WHEN 'China' THEN 'cn' WHEN 'Israel' THEN 'il' WHEN 'Palestina' THEN 'ps' WHEN 'Letonia' THEN 'lv' WHEN 'Noruega' THEN 'no'
                WHEN 'Polonia' THEN 'pl' WHEN 'Estonia' THEN 'ee' WHEN 'Colombia' THEN 'co' WHEN 'Islandia' THEN 'is' WHEN 'Rumanía' THEN 'ro'
                WHEN 'Indonesia' THEN 'id' WHEN 'Serbia' THEN 'rs' WHEN 'Suiza' THEN 'ch' WHEN 'Turquía' THEN 'tr' WHEN 'Rusia' THEN 'ru'
                WHEN 'Bosnia' THEN 'ba' WHEN 'Chile' THEN 'cl' WHEN 'Holanda' THEN 'nl' WHEN 'Finlandia' THEN 'fi' WHEN 'Tailandia' THEN 'th'
                WHEN 'Hungría' THEN 'hu' WHEN 'Uruguay' THEN 'uy' WHEN 'Arabia Saudí' THEN 'sa' WHEN 'Ucrania' THEN 'ua' WHEN 'Croacia' THEN 'hr'
                WHEN 'Marruecos' THEN 'ma' WHEN 'Egipto' THEN 'eg' WHEN 'República Checa' THEN 'cz' WHEN 'Rep.Checa' THEN 'cz' WHEN 'Paquistán' THEN 'pk'
                WHEN 'Georgia' THEN 'ge' WHEN 'Cuba' THEN 'cu' WHEN 'Portugal' THEN 'pt' WHEN 'Macedonia' THEN 'mk' WHEN 'Senegal' THEN 'sn'
                WHEN 'Afganistán' THEN 'af' WHEN 'Camboya' THEN 'kh' WHEN 'Kazajstán' THEN 'kz' WHEN 'Vietnam' THEN 'vn' WHEN 'Argelia' THEN 'dz'
                WHEN 'Botsuana' THEN 'bw' WHEN 'Eslovaquia' THEN 'sk'
                ELSE LOWER(SUBSTRING(TRIM(country) FROM 1 FOR 2))
            END as code
        FROM public.movies_staging
        WHERE country IS NOT NULL AND TRIM(country) <> ''
    ) as mapped_countries
    GROUP BY code -- Agrupamos todos los alias ('Rep. Checa', 'República Checa') en un solo 'cz'
    ON CONFLICT (code) DO NOTHING; -- Ahora el conflicto se maneja sobre el código, que es lo correcto.


    -- FASE 1: UPSERT DE PELÍCULAS Y CAPTURA DE IDs AFECTADOS
    -- ----------------------------------------------------------------
    WITH upserted_movies AS (
        INSERT INTO public.movies (
            image, title, year, year_end, type, fa_rating, fa_votes, imdb_rating, imdb_votes,
            original_title, country_id, minutes, synopsis, fa_id, imdb_id, critic, last_synced_at,
            episodes, wikipedia -- ✨ AÑADIDO
        )
        SELECT
            TRIM(s.image), s.title, public.to_integer_safe(s.year::TEXT),
            s.year_end, s.type, public.to_real_safe(s.fa_rating::TEXT), public.to_integer_safe(s.fa_votes::TEXT),
            public.to_real_safe(s.imdb_rating::TEXT), public.to_integer_safe(s.imdb_votes::TEXT),
            s.original_title, c.id, public.to_integer_safe(s.minutes::TEXT), s.synopsis, s.fa_id,
            s.imdb_id, s.critic, sync_timestamp,
            public.to_integer_safe(s.episodes::TEXT), TRIM(s.wikipedia) -- ✨ AÑADIDO
        FROM public.movies_staging s
        LEFT JOIN public.countries c ON s.country = c.name
        WHERE s.image IS NOT NULL AND TRIM(s.image) <> ''
        ON CONFLICT (image) DO UPDATE SET
            title = EXCLUDED.title, year = EXCLUDED.year, year_end = EXCLUDED.year_end, type = EXCLUDED.type,
            fa_rating = EXCLUDED.fa_rating, fa_votes = EXCLUDED.fa_votes, imdb_rating = EXCLUDED.imdb_rating,
            imdb_votes = EXCLUDED.imdb_votes, original_title = EXCLUDED.original_title, country_id = EXCLUDED.country_id,
            minutes = EXCLUDED.minutes, synopsis = EXCLUDED.synopsis, fa_id = EXCLUDED.fa_id, imdb_id = EXCLUDED.imdb_id,
            critic = EXCLUDED.critic, last_synced_at = sync_timestamp,
            episodes = EXCLUDED.episodes, wikipedia = EXCLUDED.wikipedia -- ✨ AÑADIDO
        RETURNING id
    )
    SELECT array_agg(id)
    INTO affected_movie_ids
    FROM upserted_movies;

    IF affected_movie_ids IS NULL THEN
        RETURN;
    END IF;

    -- FASE 2: BORRADO DE RELACIONES ANTIGUAS
    -- ----------------------------------------------------------------
    DELETE FROM public.movie_genres WHERE movie_id = ANY(affected_movie_ids);
    DELETE FROM public.movie_directors WHERE movie_id = ANY(affected_movie_ids);
    DELETE FROM public.movie_actors WHERE movie_id = ANY(affected_movie_ids);
    DELETE FROM public.movie_collections WHERE movie_id = ANY(affected_movie_ids);

    -- FASE 3: RECONSTRUCCIÓN DE RELACIONES NUEVAS
    -- ----------------------------------------------------------------
    INSERT INTO public.movie_genres (movie_id, genre_id)
    SELECT m.id, g.id
    FROM public.movies_staging s
    JOIN public.movies m ON TRIM(s.image) = m.image
    CROSS JOIN LATERAL UNNEST(STRING_TO_ARRAY(s.genre, ',')) AS genre_name(name)
    JOIN public.genres g ON g.name = TRIM(genre_name.name)
    WHERE m.id = ANY(affected_movie_ids) ON CONFLICT DO NOTHING;

    INSERT INTO public.movie_directors (movie_id, director_id)
    SELECT m.id, d.id
    FROM public.movies_staging s
    JOIN public.movies m ON TRIM(s.image) = m.image
    CROSS JOIN LATERAL UNNEST(STRING_TO_ARRAY(s.directors, ',')) AS director_name(name)
    JOIN public.directors d ON d.name = TRIM(director_name.name)
    WHERE m.id = ANY(affected_movie_ids) ON CONFLICT DO NOTHING;

    INSERT INTO public.movie_actors (movie_id, actor_id)
    SELECT m.id, a.id
    FROM public.movies_staging s
    JOIN public.movies m ON TRIM(s.image) = m.image
    CROSS JOIN LATERAL UNNEST(STRING_TO_ARRAY(s.actors, ',')) AS actor_name(name)
    JOIN public.actors a ON a.name = TRIM(actor_name.name)
    WHERE m.id = ANY(affected_movie_ids) AND s.actors <> '(A)' ON CONFLICT DO NOTHING;

    INSERT INTO public.movie_collections (movie_id, collection_id)
    SELECT m.id, c.id
    FROM public.movies_staging s
    JOIN public.movies m ON TRIM(s.image) = m.image
    CROSS JOIN LATERAL UNNEST(STRING_TO_ARRAY(s.collection, ',')) AS collection_code(code)
    JOIN public.collections c ON c.code = TRIM(collection_code.code)
    WHERE m.id = ANY(affected_movie_ids) ON CONFLICT DO NOTHING;

END;
$function$

-- =================================================================
-- Crear la tabla con las votaciones y las Políticas de Seguridad
-- =================================================================

-- 1. Creamos la tabla para almacenar las votaciones de los usuarios.
CREATE TABLE public.user_ratings (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    movie_id BIGINT NOT NULL REFERENCES public.movies(id) ON DELETE CASCADE,
    rating SMALLINT NOT NULL CHECK (rating >= 1 AND rating <= 10),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 2. Creamos un índice único para asegurar que un usuario solo pueda votar una vez por película.
-- Si intenta votar de nuevo, la operación deberá ser una ACTUALIZACIÓN, no una inserción.
CREATE UNIQUE INDEX user_ratings_user_movie_idx ON public.user_ratings (user_id, movie_id);

-- 3. Creamos una función para actualizar el campo 'updated_at' automáticamente.
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 4. Creamos un trigger que llame a la función anterior cada vez que se actualice una fila.
CREATE TRIGGER on_user_ratings_update
BEFORE UPDATE ON public.user_ratings
FOR EACH ROW
EXECUTE PROCEDURE public.handle_updated_at();


-- Borramos políticas antiguas si existen, para empezar de cero.
DROP POLICY IF EXISTS "Los usuarios pueden ver sus propias votaciones" ON public.user_ratings;
DROP POLICY IF EXISTS "Los usuarios pueden insertar sus propias votaciones" ON public.user_ratings;
DROP POLICY IF EXISTS "Los usuarios pueden actualizar sus propias votaciones" ON public.user_ratings;
DROP POLICY IF EXISTS "Los usuarios pueden borrar sus propias votaciones" ON public.user_ratings;

-- Política 1: SELECT (Leer)
-- Un usuario solo puede leer las filas (votaciones) que le pertenecen.
CREATE POLICY "Los usuarios pueden ver sus propias votaciones"
ON public.user_ratings FOR SELECT
USING ( auth.uid() = user_id );

-- Política 2: INSERT (Crear)
-- Un usuario solo puede insertar una fila (una nueva votación) si se identifica a sí mismo como el propietario.
CREATE POLICY "Los usuarios pueden insertar sus propias votaciones"
ON public.user_ratings FOR INSERT
WITH CHECK ( auth.uid() = user_id );

-- Política 3: UPDATE (Actualizar)
-- Un usuario solo puede actualizar una fila si esa fila le pertenece.
CREATE POLICY "Los usuarios pueden actualizar sus propias votaciones"
ON public.user_ratings FOR UPDATE
USING ( auth.uid() = user_id );

-- Política 4: DELETE (Borrar)
-- Un usuario solo puede borrar una fila si esa fila le pertenece.
CREATE POLICY "Los usuarios pueden borrar sus propias votaciones"
ON public.user_ratings FOR DELETE
USING ( auth.uid() = user_id );

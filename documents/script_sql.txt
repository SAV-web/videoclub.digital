-- =================================================================
--        SCRIPT DE CONFIGURACIÓN COMPLETO PARA VIDEOCLUB.DIGITAL (REFACTORIZADO v2.0)
-- =================================================================
-- Este script es idempotente y se puede ejecutar de forma segura.
-- Orden de ejecución:
-- 1. Habilitación de Extensiones.
-- 2. Creación de Funciones Auxiliares y modificaciones esquema/tabla
-- 3. ✨ REFACTORIZADO: Definición de la Lógica de Negocio (Función de búsqueda ultra-optimizada).
-- 4. Creación de Tablas de Usuario y Triggers.
-- 5. ✨ MEJORA: Optimización de Rendimiento (Índices y Columnas Generadas).
-- 6. Configuración de Seguridad (Row Level Security).
-- 7. ✨ REFACTORIZADO: Función de Ingesta de Datos (ETL) con fase de Desnormalización.
-- =================================================================


-- PASO 1: HABILITACIÓN DE EXTENSIONES
-- -----------------------------------------------------------------
CREATE EXTENSION IF NOT EXISTS unaccent; -- Para búsquedas insensibles a acentos.
CREATE EXTENSION IF NOT EXISTS pg_trgm;  -- Para búsquedas por similitud y `ILIKE` rápido.


-- PASO 2: CREACIÓN DE FUNCIONES AUXILIARES Y DE UTILIDAD
-- ✨ NUEVO PASO: MODIFICACIONES DE ESQUEMA Y ESTRUCTURA DE TABLAS
-- =================================================================
-- Se mueven aquí todas las modificaciones de esquema para que existan
-- ANTES de que cualquier función intente usarlas.
-- -----------------------------------------------------------------

-- Función "wrapper" inmutable para `unaccent`, necesaria para crear índices funcionales.
CREATE OR REPLACE FUNCTION public.unaccent_immutable(text)
RETURNS text LANGUAGE sql IMMUTABLE PARALLEL SAFE AS
$$
    SELECT public.unaccent('public.unaccent', $1);
$$;

-- Función para convertir texto a INTEGER de forma segura, devolviendo NULL en caso de error.
CREATE OR REPLACE FUNCTION public.to_integer_safe(v_input TEXT)
RETURNS INTEGER LANGUAGE plpgsql IMMUTABLE PARALLEL SAFE AS $$
BEGIN
    RETURN v_input::INTEGER;
EXCEPTION WHEN OTHERS THEN
    RETURN NULL;
END;
$$;

-- Función para convertir texto a REAL de forma segura, devolviendo NULL en caso de error.
CREATE OR REPLACE FUNCTION public.to_real_safe(v_input TEXT)
RETURNS REAL LANGUAGE plpgsql IMMUTABLE PARALLEL SAFE AS $$
BEGIN
    RETURN v_input::REAL;
EXCEPTION WHEN OTHERS THEN
    RETURN NULL;
END;
$$;

-- Añadimos las nuevas columnas a la tabla `movies` para la desnormalización.
ALTER TABLE public.movies ADD COLUMN IF NOT EXISTS genres_list TEXT;
ALTER TABLE public.movies ADD COLUMN IF NOT EXISTS directors_list TEXT;
ALTER TABLE public.movies ADD COLUMN IF NOT EXISTS actors_list TEXT;

-- Añadimos columnas generadas para búsquedas normalizadas (insensibles a acentos/mayúsculas).
ALTER TABLE public.movies ADD COLUMN IF NOT EXISTS title_norm TEXT GENERATED ALWAYS AS (public.unaccent_immutable(lower(title))) STORED;
ALTER TABLE public.directors ADD COLUMN IF NOT EXISTS name_norm TEXT GENERATED ALWAYS AS (public.unaccent_immutable(lower(name))) STORED;
ALTER TABLE public.actors ADD COLUMN IF NOT EXISTS name_norm TEXT GENERATED ALWAYS AS (public.unaccent_immutable(lower(name))) STORED;
ALTER TABLE public.countries ADD COLUMN IF NOT EXISTS name_norm TEXT GENERATED ALWAYS AS (public.unaccent_immutable(lower(name))) STORED;
ALTER TABLE public.genres ADD COLUMN IF NOT EXISTS name_norm TEXT GENERATED ALWAYS AS (public.unaccent_immutable(lower(name))) STORED;

-- =================================================================
-- PASO 3: ✨ REFACTORIZADO - LÓGICA DE BÚSQUEDA OPTIMIZADA
-- =================================================================
-- v2.0: Esta nueva versión es radicalmente más simple y rápida.
-- Elimina TODOS los JOINs complejos en tiempo de lectura al consultar
-- las columnas de texto pre-calculadas (genres_list, directors_list, etc.).

DROP FUNCTION IF EXISTS public.search_and_count(text, text, text, text, text, text, text, text, text, text[], text[], integer, integer);
CREATE OR REPLACE FUNCTION public.search_and_count(
    search_term text, 
    p_genre_name text, 
    p_year text, 
    p_country_name text, 
    p_director_name text, 
    p_actor_name text, 
    p_media_type text, 
    p_selection text, 
    p_sort text,
    p_excluded_genres text[],
    p_excluded_countries text[],
    p_limit integer,
    p_offset integer
)
RETURNS TABLE(
    id bigint, title text, year integer, year_end text, type text, genres text, 
    directors text, actors text, country text, country_code text, minutes integer, 
    image text, fa_id text, fa_rating real, fa_votes integer, imdb_id text, 
    imdb_rating real, imdb_votes integer, synopsis text, thumbhash_st text, 
    critic text, last_synced_at timestamptz, episodes integer, wikipedia text, total_count bigint
)
LANGUAGE sql STABLE PARALLEL SAFE AS $function$
-- El CTE (Common Table Expression - Expresión de Tabla Común) inicial sigue siendo el corazón,
-- pero ahora es mucho más eficiente al no necesitar subconsultas complejas para filtros de texto.
WITH filtered_movies AS (
    SELECT 
        m.id,
        -- La window function COUNT(*) OVER() sigue siendo la forma más eficiente
        -- de obtener el conteo total sin ejecutar la consulta dos veces.
        COUNT(*) OVER() AS total_count_unpaginated
    FROM public.movies m
    WHERE
        -- Búsqueda de título (usa el índice GIN en la columna generada `title_norm`)
        (search_term IS NULL OR search_term = '' OR m.title_norm ILIKE '%' || public.unaccent_immutable(lower(search_term)) || '%')
        
        -- Filtro de año (sin cambios, ya era eficiente)
        AND (p_year IS NULL OR 
            (p_year LIKE '%-%' AND (
                m.year <= (split_part(p_year, '-', 2)::int) AND 
                ((split_part(p_year, '-', 1)::int) = 1926 OR m.year >= (split_part(p_year, '-', 1)::int))
            )) OR 
            (p_year NOT LIKE '%-%' AND m.year = p_year::int)
        )
        
        -- Filtro de tipo de medio (sin cambios)
        AND (p_media_type IS NULL OR p_media_type = 'all' OR (p_media_type = 'movies' AND (m.type IS NULL OR m.type IN ('D', 'A'))) OR (p_media_type = 'series' AND m.type ILIKE 'S%'))
        
        -- Filtro de país (sin cambios, usa índice en country_id)
        AND (p_country_name IS NULL OR m.country_id = (SELECT c.id FROM public.countries c WHERE c.name = p_country_name))

        -- ✨ MEJORA RADICAL: Filtros de texto ahora usan las columnas desnormalizadas.
        -- Usar ILIKE aquí es increíblemente rápido porque no hay JOINs.
        AND (p_genre_name IS NULL OR m.genres_list ILIKE '%' || p_genre_name || '%')
        AND (p_director_name IS NULL OR m.directors_list ILIKE '%' || p_director_name || '%')
        AND (p_actor_name IS NULL OR m.actors_list ILIKE '%' || p_actor_name || '%')

        -- Filtro de selección (sin cambios, ya era eficiente con EXISTS)
        AND (p_selection IS NULL OR EXISTS (SELECT 1 FROM public.movie_collections mc JOIN public.collections coll ON mc.collection_id = coll.id WHERE mc.movie_id = m.id AND coll.code = p_selection))
        
        -- ✨ MEJORA RADICAL: Filtros de exclusión también usan las columnas desnormalizadas.
        AND (p_excluded_genres IS NULL OR NOT m.genres_list ILIKE ANY (SELECT '%' || g || '%' FROM unnest(p_excluded_genres) as g))
        AND (p_excluded_countries IS NULL OR array_length(p_excluded_countries, 1) IS NULL OR m.country_id NOT IN (SELECT c.id FROM public.countries c WHERE c.name = ANY(p_excluded_countries)))

    ORDER BY
        -- La ordenación permanece igual.
        CASE WHEN split_part(p_sort, ',', 1) = 'relevance' THEN public.similarity(m.title, search_term) END DESC,
        CASE WHEN split_part(p_sort, ',', 1) = 'year' AND split_part(p_sort, ',', 2) = 'desc' THEN m.year END DESC,
        CASE WHEN split_part(p_sort, ',', 1) = 'year' AND split_part(p_sort, ',', 2) = 'asc' THEN m.year END ASC,
        CASE WHEN split_part(p_sort, ',', 1) = 'fa_rating' AND split_part(p_sort, ',', 2) = 'desc' THEN m.fa_rating END DESC NULLS LAST,
        CASE WHEN split_part(p_sort, ',', 1) = 'imdb_rating' AND split_part(p_sort, ',', 2) = 'desc' THEN m.imdb_rating END DESC NULLS LAST,
        CASE WHEN split_part(p_sort, ',', 1) = 'fa_votes' AND split_part(p_sort, ',', 2) = 'desc' THEN m.fa_votes END DESC NULLS LAST,
        CASE WHEN split_part(p_sort, ',', 1) = 'imdb_votes' AND split_part(p_sort, ',', 2) = 'desc' THEN m.imdb_votes END DESC NULLS LAST,
        m.id ASC
	LIMIT p_limit
    OFFSET p_offset
)
-- La consulta final ahora es trivial. Solo necesita unir con `countries` para el código de país.
SELECT
    m.id, m.title, m.year, m.year_end, m.type,
    -- ¡EL GRAN CAMBIO! Leemos directamente las columnas pre-calculadas.
    m.genres_list AS genres,
    m.directors_list AS directors,
    m.actors_list AS actors,
    c.name AS country, c.code AS country_code,
    m.minutes, m.image, m.fa_id, m.fa_rating, m.fa_votes, m.imdb_id, m.imdb_rating, m.imdb_votes, m.synopsis, m.thumbhash_st,
    m.critic, m.last_synced_at, m.episodes, m.wikipedia,
    -- Obtenemos el conteo total del CTE.
    (SELECT total_count_unpaginated FROM filtered_movies LIMIT 1)::bigint AS total_count
FROM public.movies m
JOIN filtered_movies fm ON m.id = fm.id
LEFT JOIN public.countries c ON m.country_id = c.id
-- El GROUP BY complejo ya no es necesario. La ordenación final tampoco es necesaria
-- porque los IDs de filtered_movies ya vienen en el orden correcto.
;
$function$;


-- PASO 4: CREACIÓN DE TABLAS DE USUARIO Y TRIGGERS
-- -----------------------------------------------------------------

-- Tabla para almacenar las valoraciones de los usuarios.
CREATE TABLE IF NOT EXISTS public.user_ratings (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    movie_id BIGINT NOT NULL REFERENCES public.movies(id) ON DELETE CASCADE,
    rating SMALLINT NOT NULL CHECK (rating >= 1 AND rating <= 10),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT user_ratings_user_movie_unique UNIQUE (user_id, movie_id)
);
CREATE INDEX IF NOT EXISTS user_ratings_user_id_idx ON public.user_ratings(user_id);
CREATE INDEX IF NOT EXISTS user_ratings_movie_id_idx ON public.user_ratings(movie_id);

-- Función de trigger para actualizar automáticamente el campo 'updated_at'.
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;

-- Trigger que se activa en cada actualización de la tabla user_ratings.
DROP TRIGGER IF EXISTS on_user_ratings_update ON public.user_ratings;
CREATE TRIGGER on_user_ratings_update
BEFORE UPDATE ON public.user_ratings
FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();


-- =================================================================
-- PASO 5: OPTIMIZACIÓN DE RENDIMIENTO (ÍNDICES)
-- =================================================================

-- Creamos un índice GIN (Generalized Inverted Index) sobre la columna normalizada.
-- Es el tipo de índice más eficiente para búsquedas con `ILIKE '%...%'` cuando se usa la extensión pg_trgm.
CREATE INDEX IF NOT EXISTS movies_title_norm_trgm_idx ON public.movies USING gin (title_norm gin_trgm_ops);

-- Índices para claves foráneas y campos de ordenación comunes.
CREATE INDEX IF NOT EXISTS movies_country_id_idx ON public.movies(country_id);
CREATE INDEX IF NOT EXISTS movies_year_idx ON public.movies(year DESC);
CREATE INDEX IF NOT EXISTS movies_fa_rating_idx ON public.movies(fa_rating DESC NULLS LAST);
CREATE INDEX IF NOT EXISTS movies_imdb_rating_idx ON public.movies(imdb_rating DESC NULLS LAST);

-- Índices para las tablas de relación.
CREATE INDEX IF NOT EXISTS movie_genres_movie_id_idx ON public.movie_genres(movie_id);
CREATE INDEX IF NOT EXISTS movie_genres_genre_id_idx ON public.movie_genres(genre_id);
CREATE INDEX IF NOT EXISTS movie_directors_movie_id_idx ON public.movie_directors(movie_id);
CREATE INDEX IF NOT EXISTS movie_directors_director_id_idx ON public.movie_directors(director_id);
CREATE INDEX IF NOT EXISTS movie_actors_movie_id_idx ON public.movie_actors(movie_id);
CREATE INDEX IF NOT EXISTS movie_actors_actor_id_idx ON public.movie_actors(actor_id);
CREATE INDEX IF NOT EXISTS movie_collections_movie_id_idx ON public.movie_collections(movie_id);
CREATE INDEX IF NOT EXISTS movie_collections_collection_id_idx ON public.movie_collections(collection_id);

-- Índices híbridos para las tablas de entidad (sugerencias).
CREATE INDEX IF NOT EXISTS directors_name_norm_prefix_idx ON public.directors (name_norm text_pattern_ops);
CREATE INDEX IF NOT EXISTS directors_name_norm_trgm_idx ON public.directors USING gin (name_norm gin_trgm_ops);
CREATE INDEX IF NOT EXISTS actors_name_norm_prefix_idx ON public.actors (name_norm text_pattern_ops);
CREATE INDEX IF NOT EXISTS actors_name_norm_trgm_idx ON public.actors USING gin (name_norm gin_trgm_ops);
CREATE INDEX IF NOT EXISTS countries_name_norm_prefix_idx ON public.countries (name_norm text_pattern_ops);
CREATE INDEX IF NOT EXISTS countries_name_norm_trgm_idx ON public.countries USING gin (name_norm gin_trgm_ops);
CREATE INDEX IF NOT EXISTS genres_name_norm_prefix_idx ON public.genres (name_norm text_pattern_ops);
CREATE INDEX IF NOT EXISTS genres_name_norm_trgm_idx ON public.genres USING gin (name_norm gin_trgm_ops);

-- Actualizamos las funciones de sugerencias para que usen la nueva arquitectura.
CREATE OR REPLACE FUNCTION public.get_actor_suggestions(search_term text)
RETURNS TABLE(suggestion text) LANGUAGE plpgsql STABLE PARALLEL SAFE AS $$
BEGIN
    RETURN QUERY
    SELECT a.name
    FROM public.actors a
    JOIN public.movie_actors ma ON a.id = ma.actor_id
    WHERE a.name_norm ILIKE '%' || public.unaccent_immutable(lower(search_term)) || '%'
    GROUP BY a.name
    ORDER BY COUNT(ma.movie_id) DESC
    LIMIT 10;
END;
$$;

CREATE OR REPLACE FUNCTION public.get_director_suggestions(search_term text)
RETURNS TABLE(suggestion text) LANGUAGE plpgsql STABLE PARALLEL SAFE AS $$
BEGIN
    RETURN QUERY
    SELECT d.name
    FROM public.directors d
    JOIN public.movie_directors md ON d.id = md.director_id
    WHERE d.name_norm ILIKE '%' || public.unaccent_immutable(lower(search_term)) || '%'
    GROUP BY d.name
    ORDER BY COUNT(md.movie_id) DESC
    LIMIT 10;
END;
$$;

CREATE OR REPLACE FUNCTION public.get_genre_suggestions(search_term text)
RETURNS TABLE(suggestion text) LANGUAGE sql STABLE PARALLEL SAFE AS $$
    SELECT name FROM public.genres
    WHERE similarity(name_norm, public.unaccent_immutable(lower(search_term))) > 0.2
    ORDER BY similarity(name_norm, public.unaccent_immutable(lower(search_term))) DESC
    LIMIT 5;
$$;

CREATE OR REPLACE FUNCTION public.get_country_suggestions(search_term text)
RETURNS TABLE(suggestion text) LANGUAGE sql STABLE PARALLEL SAFE AS $$
    SELECT name FROM public.countries
    WHERE similarity(name_norm, public.unaccent_immutable(lower(search_term))) > 0.2
    ORDER BY similarity(name_norm, public.unaccent_immutable(lower(search_term))) DESC
    LIMIT 5;
$$;


-- PASO 6: CONFIGURACIÓN DE SEGURIDAD (ROW LEVEL SECURITY)
-- -----------------------------------------------------------------

-- Habilitamos RLS y definimos políticas de "solo lectura" para todas las tablas públicas.
DO $$
DECLARE
    t_name TEXT;
BEGIN
    FOR t_name IN 
        SELECT table_name FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name NOT LIKE 'pg_%' AND table_name NOT LIKE 'sql_%'
    LOOP
        EXECUTE format('ALTER TABLE public.%I ENABLE ROW LEVEL SECURITY;', t_name);
        EXECUTE format('DROP POLICY IF EXISTS "Enable read access for all users" ON public.%I;', t_name);
        EXECUTE format('CREATE POLICY "Enable read access for all users" ON public.%I FOR SELECT USING (true);', t_name);
    END LOOP;
END;
$$;

-- Definimos políticas específicas y más restrictivas para la tabla 'user_ratings'.
ALTER TABLE public.user_ratings ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Enable read access for all users" ON public.user_ratings; -- Quitamos la política pública genérica.

-- Los usuarios solo pueden ver, insertar, actualizar o borrar SUS PROPIAS valoraciones.
DROP POLICY IF EXISTS "Users can manage their own ratings" ON public.user_ratings;
CREATE POLICY "Users can manage their own ratings" ON public.user_ratings
FOR ALL
USING ( auth.uid() = user_id )
WITH CHECK ( auth.uid() = user_id );


-- =================================================================
-- PASO 7: ✨ REFACTORIZADO - FUNCIÓN DE INGESTA (ETL) CON DESNORMALIZACIÓN
-- =================================================================
-- v2.0: Añade una fase final de desnormalización para pre-calcular las listas
-- de géneros, directores y actores, optimizando drásticamente el rendimiento de lectura.

CREATE OR REPLACE FUNCTION public.process_staging_data()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    sync_timestamp TIMESTAMP WITH TIME ZONE := NOW();
    affected_movie_ids INT[];
BEGIN

    -- FASE 0: POBLAR TABLAS DE CATÁLOGO (ACTORES, DIRECTORES, GÉNEROS, PAÍSES)
    -- ----------------------------------------------------------------
    -- Se extraen los nombres únicos de la tabla de staging y se insertan en
    -- las tablas de catálogo correspondientes si aún no existen.
    
    INSERT INTO public.genres (name)
    SELECT DISTINCT TRIM(g.name)
    FROM public.movies_staging, UNNEST(STRING_TO_ARRAY(genre, ',')) AS g(name)
    WHERE genre IS NOT NULL AND TRIM(g.name) <> ''
    ON CONFLICT (name) DO NOTHING;

    INSERT INTO public.directors (name)
    SELECT DISTINCT TRIM(d.name)
    FROM public.movies_staging, UNNEST(STRING_TO_ARRAY(directors, ',')) AS d(name)
    WHERE directors IS NOT NULL AND TRIM(d.name) <> ''
    ON CONFLICT (name) DO NOTHING;

    INSERT INTO public.actors (name)
    SELECT DISTINCT TRIM(a.name)
    FROM public.movies_staging, UNNEST(STRING_TO_ARRAY(actors, ',')) AS a(name)
    WHERE actors IS NOT NULL AND TRIM(a.name) <> '' AND actors <> '(A)'
    ON CONFLICT (name) DO NOTHING;

    -- Se insertan los países, manejando alias y asegurando un código de país único.
    INSERT INTO public.countries (name, code)
    SELECT
        MIN(name) as name, -- Se elige un nombre canónico
        code
    FROM (
        SELECT DISTINCT
            TRIM(country) as name,
            CASE TRIM(country)
                WHEN 'EEUU' THEN 'us' WHEN 'Nueva Zelanda' THEN 'nz' WHEN 'Italia' THEN 'it' WHEN 'UK' THEN 'gb' WHEN 'Francia' THEN 'fr' WHEN 'Brasil' THEN 'br'
                WHEN 'Japón' THEN 'jp' WHEN 'España' THEN 'es' WHEN 'Corea del Sur' THEN 'kr' WHEN 'Australia' THEN 'au' WHEN 'Argentina' THEN 'ar'
                WHEN 'Sudáfrica' THEN 'za' WHEN 'Alemania' THEN 'de' WHEN 'Irlanda' THEN 'ie' WHEN 'México' THEN 'mx' WHEN 'Dinamarca' THEN 'dk'
                WHEN 'Suecia' THEN 'se' WHEN 'Canadá' THEN 'ca' WHEN 'Taiwán' THEN 'tw' WHEN 'Bélgica' THEN 'be' WHEN 'Hong Kong' THEN 'hk'
                WHEN 'Austria' THEN 'at' WHEN 'Irán' THEN 'ir' WHEN 'India' THEN 'in' WHEN 'Líbano' THEN 'lb' WHEN 'Grecia' THEN 'gr'
                WHEN 'China' THEN 'cn' WHEN 'Israel' THEN 'il' WHEN 'Palestina' THEN 'ps' WHEN 'Letonia' THEN 'lv' WHEN 'Noruega' THEN 'no'
                WHEN 'Polonia' THEN 'pl' WHEN 'Estonia' THEN 'ee' WHEN 'Colombia' THEN 'co' WHEN 'Islandia' THEN 'is' WHEN 'Rumanía' THEN 'ro'
                WHEN 'Indonesia' THEN 'id' WHEN 'Serbia' THEN 'rs' WHEN 'Suiza' THEN 'ch' WHEN 'Turquía' THEN 'tr' WHEN 'Rusia' THEN 'ru'
                WHEN 'Bosnia' THEN 'ba' WHEN 'Chile' THEN 'cl' WHEN 'Holanda' THEN 'nl' WHEN 'Finlandia' THEN 'fi' WHEN 'Tailandia' THEN 'th'
                WHEN 'Hungría' THEN 'hu' WHEN 'Uruguay' THEN 'uy' WHEN 'Arabia Saudí' THEN 'sa' WHEN 'Ucrania' THEN 'ua' WHEN 'Croacia' THEN 'hr'
                WHEN 'Marruecos' THEN 'ma' WHEN 'Egipto' THEN 'eg' WHEN 'República Checa' THEN 'cz' WHEN 'Rep.Checa' THEN 'cz' WHEN 'Paquistán' THEN 'pk'
                WHEN 'Georgia' THEN 'ge' WHEN 'Cuba' THEN 'cu' WHEN 'Portugal' THEN 'pt' WHEN 'Macedonia' THEN 'mk' WHEN 'Senegal' THEN 'sn'
                WHEN 'Afganistán' THEN 'af' WHEN 'Camboya' THEN 'kh' WHEN 'Kazajstán' THEN 'kz' WHEN 'Vietnam' THEN 'vn' WHEN 'Argelia' THEN 'dz'
                WHEN 'Botsuana' THEN 'bw' WHEN 'Eslovaquia' THEN 'sk'
                ELSE LOWER(SUBSTRING(TRIM(country) FROM 1 FOR 2))
            END as code
        FROM public.movies_staging
        WHERE country IS NOT NULL AND TRIM(country) <> ''
    ) as mapped_countries
    GROUP BY code
    ON CONFLICT (code) DO NOTHING;


    -- FASE 1: UPSERT DE PELÍCULAS Y CAPTURA DE IDs AFECTADOS
    -- ----------------------------------------------------------------
    -- Se insertan nuevas películas o se actualizan las existentes basadas en la columna 'image'.
    -- Los IDs de las filas afectadas se guardan para procesar sus relaciones.
    WITH upserted_movies AS (
        INSERT INTO public.movies (
            image, title, year, year_end, type, fa_rating, fa_votes, imdb_rating, imdb_votes,
            original_title, country_id, minutes, synopsis, fa_id, imdb_id, critic, last_synced_at,
            episodes, wikipedia
        )
        SELECT
            TRIM(s.image), s.title, public.to_integer_safe(s.year::TEXT),
            s.year_end, s.type, public.to_real_safe(s.fa_rating::TEXT), public.to_integer_safe(s.fa_votes::TEXT),
            public.to_real_safe(s.imdb_rating::TEXT), public.to_integer_safe(s.imdb_votes::TEXT),
            s.original_title, c.id, public.to_integer_safe(s.minutes::TEXT), s.synopsis, s.fa_id,
            s.imdb_id, s.critic, sync_timestamp,
            public.to_integer_safe(s.episodes::TEXT), TRIM(s.wikipedia)
        FROM public.movies_staging s
        LEFT JOIN public.countries c ON s.country = c.name
        WHERE s.image IS NOT NULL AND TRIM(s.image) <> ''
        ON CONFLICT (image) DO UPDATE SET
            title = EXCLUDED.title, year = EXCLUDED.year, year_end = EXCLUDED.year_end, type = EXCLUDED.type,
            fa_rating = EXCLUDED.fa_rating, fa_votes = EXCLUDED.fa_votes, imdb_rating = EXCLUDED.imdb_rating,
            imdb_votes = EXCLUDED.imdb_votes, original_title = EXCLUDED.original_title, country_id = EXCLUDED.country_id,
            minutes = EXCLUDED.minutes, synopsis = EXcluded.synopsis, fa_id = EXCLUDED.fa_id, imdb_id = EXCLUDED.imdb_id,
            critic = EXCLUDED.critic, last_synced_at = sync_timestamp,
            episodes = EXCLUDED.episodes, wikipedia = EXCLUDED.wikipedia
        RETURNING id
    )
    SELECT array_agg(id)
    INTO affected_movie_ids
    FROM upserted_movies;

    IF affected_movie_ids IS NULL THEN
        RAISE NOTICE 'No movies were inserted or updated. Exiting function.';
        RETURN;
    END IF;

    -- FASE 2: BORRADO DE RELACIONES ANTIGUAS
    -- ----------------------------------------------------------------
    -- Para las películas afectadas, se eliminan sus relaciones antiguas para
    -- asegurar que los nuevos datos de 'movies_staging' las reemplacen.
    DELETE FROM public.movie_genres WHERE movie_id = ANY(affected_movie_ids);
    DELETE FROM public.movie_directors WHERE movie_id = ANY(affected_movie_ids);
    DELETE FROM public.movie_actors WHERE movie_id = ANY(affected_movie_ids);
    DELETE FROM public.movie_collections WHERE movie_id = ANY(affected_movie_ids);

    -- FASE 3: RECONSTRUCCIÓN DE RELACIONES NUEVAS
    -- ----------------------------------------------------------------
    -- Se leen las relaciones de la tabla de staging y se insertan en las
    -- tablas de unión correspondientes (movie_genres, movie_directors, etc.).
    
    INSERT INTO public.movie_genres (movie_id, genre_id)
    SELECT m.id, g.id
    FROM public.movies_staging s
    JOIN public.movies m ON TRIM(s.image) = m.image
    CROSS JOIN LATERAL UNNEST(STRING_TO_ARRAY(s.genre, ',')) AS genre_name(name)
    JOIN public.genres g ON g.name = TRIM(genre_name.name)
    WHERE m.id = ANY(affected_movie_ids) ON CONFLICT DO NOTHING;

    INSERT INTO public.movie_directors (movie_id, director_id)
    SELECT m.id, d.id
    FROM public.movies_staging s
    JOIN public.movies m ON TRIM(s.image) = m.image
    CROSS JOIN LATERAL UNNEST(STRING_TO_ARRAY(REPLACE(s.directors, ', ', ','), ',')) AS director_name(name)
    JOIN public.directors d ON d.name = TRIM(director_name.name)
    WHERE m.id = ANY(affected_movie_ids) ON CONFLICT DO NOTHING;

    INSERT INTO public.movie_actors (movie_id, actor_id)
    SELECT m.id, a.id
    FROM public.movies_staging s
    JOIN public.movies m ON TRIM(s.image) = m.image
    CROSS JOIN LATERAL UNNEST(STRING_TO_ARRAY(REPLACE(s.actors, ', ', ','), ',')) AS actor_name(name)
    JOIN public.actors a ON a.name = TRIM(actor_name.name)
    WHERE m.id = ANY(affected_movie_ids) AND s.actors <> '(A)' ON CONFLICT DO NOTHING;

    INSERT INTO public.movie_collections (movie_id, collection_id)
    SELECT m.id, c.id
    FROM public.movies_staging s
    JOIN public.movies m ON TRIM(s.image) = m.image
    CROSS JOIN LATERAL UNNEST(STRING_TO_ARRAY(s.collection, ',')) AS collection_code(code)
    JOIN public.collections c ON c.code = TRIM(collection_code.code)
    WHERE m.id = ANY(affected_movie_ids) ON CONFLICT DO NOTHING;

    -- =================================================================
    --  ✨ NUEVA FASE 4: DESNORMALIZACIÓN (EL "MISE EN PLACE")
    -- =================================================================
    -- Una vez que todas las relaciones están actualizadas, pre-calculamos
    -- las listas de texto. Este trabajo pesado se hace aquí, en tiempo de escritura,
    -- para que las lecturas del usuario sean ultrarrápidas.
    
    WITH aggregated_data AS (
        SELECT
            m.id,
            -- Usamos STRING_AGG para concatenar los nombres de las tablas relacionadas.
            -- El 'DISTINCT' previene duplicados y 'ORDER BY' asegura un orden consistente.
            STRING_AGG(DISTINCT g.name, ', ' ORDER BY g.name) AS genres,
            STRING_AGG(DISTINCT d.name, ', ' ORDER BY d.name) AS directors,
            STRING_AGG(DISTINCT a.name, ', ' ORDER BY a.name) AS actors
        FROM public.movies m
        -- Hacemos LEFT JOIN para asegurarnos de que se incluyan todas las películas.
        LEFT JOIN public.movie_genres mg ON m.id = mg.movie_id
        LEFT JOIN public.genres g ON mg.genre_id = g.id
        LEFT JOIN public.movie_directors md ON m.id = md.movie_id
        LEFT JOIN public.directors d ON md.director_id = d.id
        LEFT JOIN public.movie_actors ma ON m.id = ma.movie_id
        LEFT JOIN public.actors a ON ma.actor_id = a.id
        -- ¡CRÍTICO! Solo procesamos las películas que fueron afectadas en esta ejecución.
        WHERE m.id = ANY(affected_movie_ids)
        GROUP BY m.id
    )
    -- Ahora actualizamos la tabla 'movies' con los datos pre-calculados.
    UPDATE public.movies m
    SET
        genres_list = ad.genres,
        directors_list = ad.directors,
        actors_list = ad.actors
    FROM aggregated_data ad
    WHERE m.id = ad.id;

END;
$function$;
-- =================================================================
-- SCRIPT DE CONFIGURACIÓN COMPLETO PARA VIDEOCLUB.DIGITAL
-- =================================================================
-- Este script es idempotente y se puede ejecutar de forma segura. Orden de ejecución:
-- 1. Habilitación de Extensiones
-- 2. Creación de Funciones Auxiliares y modificaciones esquema/tabla
-- 3. Definición de la Lógica de Negocio (Función de búsqueda ultra-optimizada)
-- 4. Creación de Tablas de Usuario y Triggers
-- 5. Optimización de Rendimiento (Índices y Columnas Generadas)
-- 6. Configuración de Seguridad (Row Level Security)
-- 7. Función de Ingesta de Datos (ETL) con fase de Desnormalización
-- =================================================================

-- =================================================================
-- PASO 1: HABILITACIÓN DE EXTENSIONES
-- =================================================================
CREATE EXTENSION IF NOT EXISTS unaccent; -- Para búsquedas insensibles a acentos.
CREATE EXTENSION IF NOT EXISTS pg_trgm;  -- Para búsquedas por similitud y `ILIKE` rápido.

-- =================================================================
-- PASO 2: CREACIÓN DE FUNCIONES AUXILIARES Y DE UTILIDAD
-- MODIFICACIONES DE ESQUEMA Y ESTRUCTURA DE TABLAS
-- =================================================================
-- Función "wrapper" inmutable para `unaccent`, necesaria para crear índices funcionales.
CREATE OR REPLACE FUNCTION public.unaccent_immutable(text)
RETURNS text LANGUAGE sql IMMUTABLE PARALLEL SAFE AS
$$ SELECT public.unaccent('public.unaccent', $1); $$;
-- Función para convertir texto a INTEGER de forma segura, devolviendo NULL en caso de error.
CREATE OR REPLACE FUNCTION public.to_integer_safe(v_input TEXT)
RETURNS INTEGER LANGUAGE plpgsql IMMUTABLE PARALLEL SAFE AS $$
BEGIN RETURN v_input::INTEGER; EXCEPTION WHEN OTHERS THEN RETURN NULL; END; $$;
-- Función para convertir texto a REAL de forma segura, devolviendo NULL en caso de error.
CREATE OR REPLACE FUNCTION public.to_real_safe(v_input TEXT)
RETURNS REAL LANGUAGE plpgsql IMMUTABLE PARALLEL SAFE AS $$
BEGIN RETURN v_input::REAL; EXCEPTION WHEN OTHERS THEN RETURN NULL; END; $$;

-- =================================================================
-- PASO 3: LÓGICA DE BÚSQUEDA OPTIMIZADA: FUNCIÓN BASADA EN OFFSET
-- =================================================================
-- Aplazamos la versión de cursor, ya que la paginación por OFFSET está optimizada para datasets
-- de tamaño medio (hasta ~50,000 registros) y se requiere poder saltar a páginas específicas.
CREATE OR REPLACE FUNCTION public.search_movies_offset(
    search_term text, genre_name text, p_year_start integer, p_year_end integer,
    country_name text, director_name text, actor_name text, media_type text,
    selection_code text, sort_by text, excluded_genres text[], excluded_countries text[],
    page_limit integer, page_offset integer
)
RETURNS TABLE(
    id bigint, title text, year integer, year_end text, type text, genres text,
    directors text, actors text, country text, country_code text, minutes integer,
    image text, fa_id text, fa_rating real, fa_votes integer, imdb_id text,
    imdb_rating real, imdb_votes integer, synopsis text, thumbhash_st text,
    critic text, last_synced_at timestamp with time zone, episodes integer, wikipedia text,
    -- ==========================================================
    --  ▼▼▼ 1. AÑADIR LA NUEVA COLUMNA A LA DEFINICIÓN DE RETORNO ▼▼▼
    -- ==========================================================
    collections_list text,
    -- ==========================================================
    total_count bigint
)
LANGUAGE sql STABLE PARALLEL SAFE AS $function$
WITH filtered_movies AS (
    -- ... (esta parte interna de la función no cambia) ...
    SELECT
        m.id,
        COUNT(*) OVER() AS total_count_unpaginated
    FROM
        public.movies m
    WHERE
        (search_term IS NULL OR search_term = '' OR m.title_norm ILIKE '%' || public.unaccent_immutable(lower(search_term)) || '%')
        AND (p_year_start IS NULL OR m.year >= p_year_start) AND (p_year_end IS NULL OR m.year <= p_year_end)
        AND (media_type IS NULL OR media_type = 'all' OR (media_type = 'movies' AND (m.type IS NULL OR m.type IN ('D', 'A'))) OR (media_type = 'series' AND m.type ILIKE 'S%'))
        AND (country_name IS NULL OR m.country_id = (SELECT c.id FROM public.countries c WHERE c.name = country_name))
        AND (genre_name IS NULL OR m.genres_list ILIKE '%' || genre_name || '%')
        AND (director_name IS NULL OR m.directors_list ILIKE '%' || director_name || '%')
        AND (actor_name IS NULL OR m.actors_list ILIKE '%' || actor_name || '%')
        AND (selection_code IS NULL OR EXISTS (SELECT 1 FROM public.movie_collections mc JOIN public.collections coll ON mc.collection_id = coll.id WHERE mc.movie_id = m.id AND coll.code = selection_code))
        AND (excluded_genres IS NULL OR NOT m.genres_list ILIKE ANY (SELECT '%' || g || '%' FROM unnest(excluded_genres) as g))
        AND (excluded_countries IS NULL OR array_length(excluded_countries, 1) IS NULL OR m.country_id NOT IN (SELECT c.id FROM public.countries c WHERE c.name = ANY(excluded_countries)))
    ORDER BY
        CASE WHEN split_part(sort_by, ',', 1) = 'relevance' OR COALESCE(TRIM(sort_by), '') = '' THEN m.relevance END ASC,
        CASE WHEN split_part(sort_by, ',', 1) = 'year' AND split_part(sort_by, ',', 2) = 'desc' THEN m.year END DESC,
        CASE WHEN split_part(sort_by, ',', 1) = 'year' AND split_part(sort_by, ',', 2) = 'asc' THEN m.year END ASC,
        CASE WHEN split_part(sort_by, ',', 1) = 'fa_rating' AND split_part(sort_by, ',', 2) = 'desc' THEN m.fa_rating END DESC NULLS LAST,
        CASE WHEN split_part(sort_by, ',', 1) = 'imdb_rating' AND split_part(sort_by, ',', 2) = 'desc' THEN m.imdb_rating END DESC NULLS LAST,
        CASE WHEN split_part(sort_by, ',', 1) = 'fa_votes' AND split_part(sort_by, ',', 2) = 'desc' THEN m.fa_votes END DESC NULLS LAST,
        CASE WHEN split_part(sort_by, ',', 1) = 'imdb_votes' AND split_part(sort_by, ',', 2) = 'desc' THEN m.imdb_votes END DESC NULLS LAST,
        m.id ASC
)
SELECT
    m.id, m.title, m.year, m.year_end, m.type, m.genres_list AS genres,
    m.directors_list AS directors, m.actors_list AS actors, c.name AS country,
    c.code AS country_code, m.minutes, m.image, m.fa_id, m.fa_rating, m.fa_votes,
    m.imdb_id, m.imdb_rating, m.imdb_votes, m.synopsis, m.thumbhash_st, m.critic,
    m.last_synced_at, m.episodes, m.wikipedia,
    -- ==========================================================
    --  ▼▼▼ 2. AÑADIR LA NUEVA COLUMNA AL SELECT FINAL ▼▼▼
    -- ==========================================================
    m.collections_list,
    -- ==========================================================
    fm.total_count_unpaginated as total_count
FROM
    filtered_movies fm
JOIN public.movies m ON fm.id = m.id
LEFT JOIN public.countries c ON m.country_id = c.id
ORDER BY
    CASE WHEN split_part(sort_by, ',', 1) = 'relevance' OR COALESCE(TRIM(sort_by), '') = '' THEN m.relevance END ASC,
    CASE WHEN split_part(sort_by, ',', 1) = 'year' AND split_part(sort_by, ',', 2) = 'desc' THEN m.year END DESC,
    CASE WHEN split_part(sort_by, ',', 1) = 'year' AND split_part(sort_by, ',', 2) = 'asc' THEN m.year END ASC,
    CASE WHEN split_part(sort_by, ',', 1) = 'fa_rating' AND split_part(sort_by, ',', 2) = 'desc' THEN m.fa_rating END DESC NULLS LAST,
    CASE WHEN split_part(sort_by, ',', 1) = 'imdb_rating' AND split_part(sort_by, ',', 2) = 'desc' THEN m.imdb_rating END DESC NULLS LAST,
    CASE WHEN split_part(sort_by, ',', 1) = 'fa_votes' AND split_part(sort_by, ',', 2) = 'desc' THEN m.fa_votes END DESC NULLS LAST,
    CASE WHEN split_part(sort_by, ',', 1) = 'imdb_votes' AND split_part(sort_by, ',', 2) = 'desc' THEN m.imdb_votes END DESC NULLS LAST,
    m.id ASC
LIMIT page_limit
OFFSET page_offset;
$function$;

-- =================================================================
-- PASO 4: REFACTORIZACIÓN DE TABLAS DE USUARIO Y TRIGGERS
-- =================================================================

-- 4.1. Limpieza de estructuras obsoletas.
-- Asegura que las tablas y tipos antiguos sean eliminados antes de crear los nuevos.
DROP TABLE IF EXISTS public.user_ratings;
DROP TABLE IF EXISTS public.user_movie_lists;
DROP TYPE IF EXISTS public.user_list_type;

-- 4.2. Creación de la nueva tabla consolidada 'user_movie_entries'.
CREATE TABLE IF NOT EXISTS public.user_movie_entries (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    movie_id BIGINT NOT NULL REFERENCES public.movies(id) ON DELETE CASCADE,
    
    on_watchlist BOOLEAN DEFAULT false,
    rating SMALLINT CHECK (rating >= 1 AND rating <= 10),
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),

    CONSTRAINT user_movie_entry_unique UNIQUE (user_id, movie_id)
);

-- 4.3. Creación de índices para optimizar el rendimiento.
CREATE INDEX IF NOT EXISTS user_movie_entries_user_id_idx ON public.user_movie_entries(user_id);
CREATE INDEX IF NOT EXISTS user_movie_entries_movie_id_idx ON public.user_movie_entries(movie_id);

-- 4.4. Función de trigger y trigger para 'updated_at'.
-- Esta función se reutiliza para la nueva tabla.
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS on_user_movie_entries_update ON public.user_movie_entries;
CREATE TRIGGER on_user_movie_entries_update
BEFORE UPDATE ON public.user_movie_entries
FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();

-- =================================================================
-- PASO 5: OPTIMIZACIÓN DE RENDIMIENTO (ÍNDICES)
-- =================================================================
-- Creamos un índice GIN (Generalized Inverted Index) sobre la columna normalizada.
-- Es el tipo de índice más eficiente para búsquedas con `ILIKE '%...%'` cuando se usa la extensión pg_trgm.
CREATE INDEX IF NOT EXISTS movies_title_norm_trgm_idx ON public.movies USING gin (title_norm gin_trgm_ops);
-- Índices para claves foráneas y campos de ordenación comunes.
CREATE INDEX IF NOT EXISTS movies_country_id_idx ON public.movies(country_id);
CREATE INDEX IF NOT EXISTS movies_year_idx ON public.movies(year DESC);
CREATE INDEX IF NOT EXISTS movies_fa_rating_idx ON public.movies(fa_rating DESC NULLS LAST);
CREATE INDEX IF NOT EXISTS movies_imdb_rating_idx ON public.movies(imdb_rating DESC NULLS LAST);
-- Índices para las tablas de relación.
CREATE INDEX IF NOT EXISTS movie_genres_movie_id_idx ON public.movie_genres(movie_id);
CREATE INDEX IF NOT EXISTS movie_genres_genre_id_idx ON public.movie_genres(genre_id);
CREATE INDEX IF NOT EXISTS movie_directors_movie_id_idx ON public.movie_directors(movie_id);
CREATE INDEX IF NOT EXISTS movie_directors_director_id_idx ON public.movie_directors(director_id);
CREATE INDEX IF NOT EXISTS movie_actors_movie_id_idx ON public.movie_actors(movie_id);
CREATE INDEX IF NOT EXISTS movie_actors_actor_id_idx ON public.movie_actors(actor_id);
CREATE INDEX IF NOT EXISTS movie_collections_movie_id_idx ON public.movie_collections(movie_id);
CREATE INDEX IF NOT EXISTS movie_collections_collection_id_idx ON public.movie_collections(collection_id);
-- Índice para guardar el orden de los actores y su índice.
CREATE INDEX IF NOT EXISTS movie_actors_ordinality_idx ON public.movie_actors(ordinality);
-- Índices híbridos para las tablas de entidad (sugerencias).
CREATE INDEX IF NOT EXISTS directors_name_norm_prefix_idx ON public.directors (name_norm text_pattern_ops);
CREATE INDEX IF NOT EXISTS directors_name_norm_trgm_idx ON public.directors USING gin (name_norm gin_trgm_ops);
CREATE INDEX IF NOT EXISTS actors_name_norm_prefix_idx ON public.actors (name_norm text_pattern_ops);
CREATE INDEX IF NOT EXISTS actors_name_norm_trgm_idx ON public.actors USING gin (name_norm gin_trgm_ops);
CREATE INDEX IF NOT EXISTS countries_name_norm_prefix_idx ON public.countries (name_norm text_pattern_ops);
CREATE INDEX IF NOT EXISTS countries_name_norm_trgm_idx ON public.countries USING gin (name_norm gin_trgm_ops);
CREATE INDEX IF NOT EXISTS genres_name_norm_prefix_idx ON public.genres (name_norm text_pattern_ops);
CREATE INDEX IF NOT EXISTS genres_name_norm_trgm_idx ON public.genres USING gin (name_norm gin_trgm_ops);
-- Actualizamos las funciones de sugerencias para que usen la nueva arquitectura.
CREATE OR REPLACE FUNCTION public.get_actor_suggestions(search_term text)
RETURNS TABLE(suggestion text) LANGUAGE plpgsql STABLE PARALLEL SAFE AS $$
BEGIN
    RETURN QUERY
    SELECT a.name
    FROM public.actors a
    JOIN public.movie_actors ma ON a.id = ma.actor_id
    WHERE a.name_norm ILIKE '%' || public.unaccent_immutable(lower(search_term)) || '%'
    GROUP BY a.name
    ORDER BY COUNT(ma.movie_id) DESC
    LIMIT 10;
END;
$$;
CREATE OR REPLACE FUNCTION public.get_director_suggestions(search_term text)
RETURNS TABLE(suggestion text) LANGUAGE plpgsql STABLE PARALLEL SAFE AS $$
BEGIN
    RETURN QUERY
    SELECT d.name
    FROM public.directors d
    JOIN public.movie_directors md ON d.id = md.director_id
    WHERE d.name_norm ILIKE '%' || public.unaccent_immutable(lower(search_term)) || '%'
    GROUP BY d.name
    ORDER BY COUNT(md.movie_id) DESC
    LIMIT 10;
END;
$$;
CREATE OR REPLACE FUNCTION public.get_genre_suggestions(search_term text)
RETURNS TABLE(suggestion text) LANGUAGE sql STABLE PARALLEL SAFE AS $$
    SELECT name FROM public.genres
    WHERE similarity(name_norm, public.unaccent_immutable(lower(search_term))) > 0.2
    ORDER BY similarity(name_norm, public.unaccent_immutable(lower(search_term))) DESC
    LIMIT 5;
$$;
CREATE OR REPLACE FUNCTION public.get_country_suggestions(search_term text)
RETURNS TABLE(suggestion text) LANGUAGE sql STABLE PARALLEL SAFE AS $$
    SELECT name FROM public.countries
    WHERE similarity(name_norm, public.unaccent_immutable(lower(search_term))) > 0.2
    ORDER BY similarity(name_norm, public.unaccent_immutable(lower(search_term))) DESC
    LIMIT 5;
$$;

-- =================================================================
-- PASO 6: CONFIGURACIÓN DE SEGURIDAD (ROW LEVEL SECURITY)
-- =================================================================

-- 6.1. Habilitamos RLS y políticas de solo lectura para tablas públicas.
DO $$ DECLARE t_name TEXT; BEGIN
    FOR t_name IN SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name NOT IN ('user_movie_entries') AND table_name NOT LIKE 'pg_%' AND table_name NOT LIKE 'sql_%'
    LOOP
        EXECUTE format('ALTER TABLE public.%I ENABLE ROW LEVEL SECURITY;', t_name);
        EXECUTE format('DROP POLICY IF EXISTS "Enable read access for all users" ON public.%I;', t_name);
        EXECUTE format('CREATE POLICY "Enable read access for all users" ON public.%I FOR SELECT USING (true);', t_name);
    END LOOP;
END; $$;

-- 6.2. Políticas de seguridad específicas para la nueva tabla 'user_movie_entries'.
ALTER TABLE public.user_movie_entries ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Los usuarios pueden gestionar sus propias entradas" ON public.user_movie_entries;
DROP POLICY IF EXISTS "Los usuarios pueden leer sus propias entradas" ON public.user_movie_entries;

CREATE POLICY "Los usuarios pueden leer sus propias entradas"
ON public.user_movie_entries FOR SELECT
USING ( auth.uid() = user_id );

CREATE POLICY "Los usuarios pueden gestionar sus propias entradas"
ON public.user_movie_entries FOR ALL -- (INSERT, UPDATE, DELETE)
USING ( auth.uid() = user_id )
WITH CHECK ( auth.uid() = user_id );

-- =================================================================
-- PASO 7: FUNCIÓN DE INGESTA (ETL) CON DESNORMALIZACIÓN
-- =================================================================
-- v2.0: Añade una fase final de desnormalización para pre-calcular las listas
-- de géneros, directores y actores, optimizando drásticamente el rendimiento de lectura.
CREATE OR REPLACE FUNCTION public.process_staging_data()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    sync_timestamp TIMESTAMP WITH TIME ZONE := NOW();
    affected_movie_ids INT[];
BEGIN

    -- FASE 0: POBLAR TABLAS DE CATÁLOGO (SIN LÓGICA DE PAÍSES)
    -- ----------------------------------------------------------------
    -- Se asume que la tabla `countries` está pre-poblada y es la única fuente de verdad.
    -- Solo se pueblan los catálogos que pueden crecer dinámicamente (géneros, directores, actores).
    INSERT INTO public.genres (name)
    SELECT DISTINCT TRIM(g.name)
    FROM public.movies_staging, UNNEST(STRING_TO_ARRAY(genre, ',')) AS g(name)
    WHERE genre IS NOT NULL AND TRIM(g.name) <> ''
    ON CONFLICT (name) DO NOTHING;

    INSERT INTO public.directors (name)
    SELECT DISTINCT TRIM(d.name)
    FROM public.movies_staging, UNNEST(STRING_TO_ARRAY(directors, ',')) AS d(name)
    WHERE directors IS NOT NULL AND TRIM(d.name) <> ''
    ON CONFLICT (name) DO NOTHING;

    INSERT INTO public.actors (name)
    SELECT DISTINCT TRIM(a.name)
    FROM public.movies_staging, UNNEST(STRING_TO_ARRAY(actors, ',')) AS a(name)
    WHERE actors IS NOT NULL AND TRIM(a.name) <> '' AND actors <> '(A)'
    ON CONFLICT (name) DO NOTHING;

    -- FASE 1: UPSERT DE PELÍCULAS Y CAPTURA DE IDs AFECTADOS
    -- ----------------------------------------------------------------
    -- Se insertan o actualizan películas. La columna `country_id` se obtiene
    -- mediante un `LEFT JOIN` directo a la tabla `countries`.
    WITH upserted_movies AS (
        INSERT INTO public.movies (
            relevance, image, title, year, year_end, type, fa_rating, fa_votes, imdb_rating, imdb_votes,
            original_title, country_id, minutes, synopsis, fa_id, imdb_id, critic, last_synced_at,
            episodes, wikipedia
        )
        SELECT
            s.relevance, TRIM(s.image), s.title, public.to_integer_safe(s.year::TEXT),
            s.year_end, s.type, public.to_real_safe(s.fa_rating::TEXT), public.to_integer_safe(s.fa_votes::TEXT),
            public.to_real_safe(s.imdb_rating::TEXT), public.to_integer_safe(s.imdb_votes::TEXT),
            s.original_title,
            -- Aquí está la lógica clave: se une directamente por el nombre.
            -- Si no hay coincidencia, c.id será NULL.
            c.id,
            public.to_integer_safe(s.minutes::TEXT), s.synopsis, s.fa_id,
            s.imdb_id, s.critic, sync_timestamp,
            public.to_integer_safe(s.episodes::TEXT), TRIM(s.wikipedia)
        FROM public.movies_staging s
        LEFT JOIN public.countries c ON TRIM(s.country) = c.name
        WHERE s.image IS NOT NULL AND TRIM(s.image) <> ''
        ON CONFLICT (image) DO UPDATE SET
            relevance = EXCLUDED.relevance, title = EXCLUDED.title, year = EXCLUDED.year, year_end = EXCLUDED.year_end, type = EXCLUDED.type,
            fa_rating = EXCLUDED.fa_rating, fa_votes = EXCLUDED.fa_votes, imdb_rating = EXCLUDED.imdb_rating,
            imdb_votes = EXCLUDED.imdb_votes, original_title = EXCLUDED.original_title, country_id = EXCLUDED.country_id,
            minutes = EXCLUDED.minutes, synopsis = EXCLUDED.synopsis, fa_id = EXCLUDED.fa_id, imdb_id = EXCLUDED.imdb_id,
            critic = EXCLUDED.critic, last_synced_at = sync_timestamp,
            episodes = EXCLUDED.episodes, wikipedia = EXCLUDED.wikipedia
        RETURNING id
    )
    SELECT array_agg(id)
    INTO affected_movie_ids
    FROM upserted_movies;

    IF affected_movie_ids IS NULL THEN
        RAISE NOTICE 'No movies were inserted or updated. Exiting function.';
        RETURN;
    END IF;

    -- FASE 2: BORRADO DE RELACIONES ANTIGUAS
    -- ----------------------------------------------------------------
    -- Para las películas afectadas, se eliminan sus relaciones antiguas para
    -- asegurar que los nuevos datos de 'movies_staging' las reemplacen.
    DELETE FROM public.movie_genres WHERE movie_id = ANY(affected_movie_ids);
    DELETE FROM public.movie_directors WHERE movie_id = ANY(affected_movie_ids);
    DELETE FROM public.movie_actors WHERE movie_id = ANY(affected_movie_ids);
    DELETE FROM public.movie_collections WHERE movie_id = ANY(affected_movie_ids);

    -- FASE 3: RECONSTRUCCIÓN DE RELACIONES NUEVAS
    -- ----------------------------------------------------------------
    -- Se leen las relaciones de la tabla de staging y se insertan en las
    -- tablas de unión correspondientes (movie_genres, movie_directors, etc.).
    
    INSERT INTO public.movie_genres (movie_id, genre_id)
    SELECT m.id, g.id
    FROM public.movies_staging s
    JOIN public.movies m ON TRIM(s.image) = m.image
    CROSS JOIN LATERAL UNNEST(STRING_TO_ARRAY(s.genre, ',')) AS genre_name(name)
    JOIN public.genres g ON g.name = TRIM(genre_name.name)
    WHERE m.id = ANY(affected_movie_ids) ON CONFLICT DO NOTHING;

    INSERT INTO public.movie_directors (movie_id, director_id)
    SELECT m.id, d.id
    FROM public.movies_staging s
    JOIN public.movies m ON TRIM(s.image) = m.image
    CROSS JOIN LATERAL UNNEST(STRING_TO_ARRAY(REPLACE(s.directors, ', ', ','), ',')) AS director_name(name)
    JOIN public.directors d ON d.name = TRIM(director_name.name)
    WHERE m.id = ANY(affected_movie_ids) ON CONFLICT (movie_id, director_id) DO NOTHING;

    INSERT INTO public.movie_actors (movie_id, actor_id, ordinality)
    -- Usamos DISTINCT ON para asegurarnos de que solo insertamos la primera aparición de cada actor por película,
    -- evitando así el error "cannot affect row a second time" si un actor está duplicado en la cadena de texto.
    SELECT DISTINCT ON (m.id, a.id) m.id, a.id, actor_name.ordinality
    FROM public.movies_staging s
    JOIN public.movies m ON TRIM(s.image) = m.image
    CROSS JOIN LATERAL UNNEST(STRING_TO_ARRAY(REPLACE(s.actors, ', ', ','), ',')) WITH ORDINALITY AS actor_name(name, ordinality)
    JOIN public.actors a ON a.name = TRIM(actor_name.name)
    WHERE m.id = ANY(affected_movie_ids) AND s.actors <> '(A)'
    ORDER BY m.id, a.id, actor_name.ordinality ASC ON CONFLICT (movie_id, actor_id) DO UPDATE SET ordinality = EXCLUDED.ordinality;

    INSERT INTO public.movie_collections (movie_id, collection_id)
    SELECT m.id, c.id
    FROM public.movies_staging s
    JOIN public.movies m ON TRIM(s.image) = m.image
    CROSS JOIN LATERAL UNNEST(STRING_TO_ARRAY(s.collection, ',')) AS collection_code(code)
    JOIN public.collections c ON c.code = TRIM(collection_code.code)
    WHERE m.id = ANY(affected_movie_ids) ON CONFLICT (movie_id, collection_id) DO NOTHING;

    -- FASE 4: DESNORMALIZACIÓN (EL "MISE EN PLACE")
    -- ----------------------------------------------------------------
    -- Una vez que todas las relaciones están actualizadas, pre-calculamos
    -- las listas de texto. Este trabajo pesado se hace aquí, en tiempo de escritura,
    -- para que las lecturas del usuario sean ultrarrápidas.
    
    WITH aggregated_data AS (
        SELECT
            m.id,
            -- Usamos STRING_AGG para concatenar los nombres de las tablas relacionadas.
            STRING_AGG(DISTINCT g.name, ', ' ORDER BY g.name) AS genres,
            STRING_AGG(DISTINCT d.name, ', ' ORDER BY d.name) AS directors,
            -- ==========================================================
            --  ▼▼▼ NUEVA LÍNEA AÑADIDA ▼▼▼
            -- ==========================================================
            STRING_AGG(DISTINCT c.code, ',') AS collections, -- Agregamos los códigos de colección
            -- ==========================================================
            (
                -- Subconsulta para obtener actores únicos ordenados por su aparición original.
                -- Esto evita la duplicación causada por los JOINs con géneros/directores.
                SELECT STRING_AGG(actor_name, ', ' ORDER BY ordinality)
                FROM (
                    SELECT DISTINCT ON (a.name) a.name as actor_name, ma.ordinality
                    FROM public.movie_actors ma
                    JOIN public.actors a ON ma.actor_id = a.id
                    WHERE ma.movie_id = m.id
                    ORDER BY a.name, ma.ordinality
                ) AS unique_actors
            ) AS actors
        FROM public.movies m
        -- Hacemos LEFT JOIN para asegurarnos de que se incluyan todas las películas.
        LEFT JOIN public.movie_genres mg ON m.id = mg.movie_id
        LEFT JOIN public.genres g ON mg.genre_id = g.id
        LEFT JOIN public.movie_directors md ON m.id = md.movie_id
        LEFT JOIN public.directors d ON md.director_id = d.id
        -- ==========================================================
        --  ▼▼▼ NUEVOS JOINS AÑADIDOS ▼▼▼
        -- ==========================================================
        LEFT JOIN public.movie_collections mc ON m.id = mc.movie_id
        LEFT JOIN public.collections c ON mc.collection_id = c.id
        -- ==========================================================
        -- ¡CRÍTICO! Solo procesamos las películas que fueron afectadas en esta ejecución.
        WHERE m.id = ANY(affected_movie_ids)
        GROUP BY m.id
    )
    -- Ahora actualizamos la tabla 'movies' con los datos pre-calculados.
    UPDATE public.movies m
    SET
        genres_list = ad.genres,
        directors_list = ad.directors,
        actors_list = ad.actors,
        -- ==========================================================
        --  ▼▼▼ NUEVA ASIGNACIÓN AÑADIDA ▼▼▼
        -- ==========================================================
        collections_list = ad.collections
        -- ==========================================================
    FROM aggregated_data ad
    WHERE m.id = ad.id;
END;
$function$;
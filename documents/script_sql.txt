-- =================================================================
-- SCRIPT DE CONFIGURACIÓN COMPLETO PARA VIDEOCLUB.DIGITAL
-- =================================================================
-- Este script es idempotente y se puede ejecutar de forma segura. Orden de ejecución:
-- 1. Habilitación de Extensiones
-- 2. Creación de Funciones Auxiliares y modificaciones esquema/tabla
-- 3. Definición de la Lógica de Negocio (Función de búsqueda ultra-optimizada)
-- 4. Creación de Tablas de Usuario y Triggers
-- 5. Optimización de Rendimiento (Índices y Columnas Generadas)
-- 6. Configuración de Seguridad (Row Level Security)
-- 7. Función de Ingesta de Datos (ETL) con fase de Desnormalización
-- =================================================================

-- =================================================================
-- PASO 1: HABILITACIÓN DE EXTENSIONES
-- =================================================================
CREATE EXTENSION IF NOT EXISTS unaccent; -- Para búsquedas insensibles a acentos.
CREATE EXTENSION IF NOT EXISTS pg_trgm;  -- Para búsquedas por similitud y `ILIKE` rápido.

-- =================================================================
-- PASO 2: CREACIÓN DE FUNCIONES AUXILIARES Y DE UTILIDAD
-- MODIFICACIONES DE ESQUEMA Y ESTRUCTURA DE TABLAS
-- =================================================================
-- Función "wrapper" inmutable para `unaccent`, necesaria para crear índices funcionales.
CREATE OR REPLACE FUNCTION public.unaccent_immutable(text)
RETURNS text LANGUAGE sql IMMUTABLE PARALLEL SAFE AS
$$
    SELECT public.unaccent('public.unaccent', $1);
$$;
-- Función para convertir texto a INTEGER de forma segura, devolviendo NULL en caso de error.
CREATE OR REPLACE FUNCTION public.to_integer_safe(v_input TEXT)
RETURNS INTEGER LANGUAGE plpgsql IMMUTABLE PARALLEL SAFE AS $$
BEGIN
    RETURN v_input::INTEGER;
EXCEPTION WHEN OTHERS THEN
    RETURN NULL;
END;
$$;
-- Función para convertir texto a REAL de forma segura, devolviendo NULL en caso de error.
CREATE OR REPLACE FUNCTION public.to_real_safe(v_input TEXT)
RETURNS REAL LANGUAGE plpgsql IMMUTABLE PARALLEL SAFE AS $$
BEGIN
    RETURN v_input::REAL;
EXCEPTION WHEN OTHERS THEN
    RETURN NULL;
END;
$$;
-- Modificaciones de esquema para que existan ANTES de que cualquier función intente usarlas.
-- Añadimos las nuevas columnas a la tabla `movies` para la desnormalización.
ALTER TABLE public.movies ADD COLUMN IF NOT EXISTS genres_list TEXT;
ALTER TABLE public.movies ADD COLUMN IF NOT EXISTS directors_list TEXT;
ALTER TABLE public.movies ADD COLUMN IF NOT EXISTS actors_list TEXT;
-- Añadimos columnas generadas para búsquedas normalizadas (insensibles a acentos/mayúsculas).
ALTER TABLE public.movies ADD COLUMN IF NOT EXISTS title_norm TEXT GENERATED ALWAYS AS (public.unaccent_immutable(lower(title))) STORED;
ALTER TABLE public.directors ADD COLUMN IF NOT EXISTS name_norm TEXT GENERATED ALWAYS AS (public.unaccent_immutable(lower(name))) STORED;
ALTER TABLE public.actors ADD COLUMN IF NOT EXISTS name_norm TEXT GENERATED ALWAYS AS (public.unaccent_immutable(lower(name))) STORED;
ALTER TABLE public.countries ADD COLUMN IF NOT EXISTS name_norm TEXT GENERATED ALWAYS AS (public.unaccent_immutable(lower(name))) STORED;
ALTER TABLE public.genres ADD COLUMN IF NOT EXISTS name_norm TEXT GENERATED ALWAYS AS (public.unaccent_immutable(lower(name))) STORED;

-- =================================================================
-- PASO 3: LÓGICA DE BÚSQUEDA OPTIMIZADA: FUNCIÓN BASADA EN OFFSET
-- =================================================================
-- Esta función reemplaza la versión de cursor. Está optimizada para
-- datasets de tamaño medio (hasta ~50,000 registros) donde la paginación
-- por OFFSET es aceptable y se requiere poder saltar a páginas específicas.

CREATE OR REPLACE FUNCTION public.search_movies_offset(
    -- ✨ CORRECCIÓN: Nombres de argumentos simplificados y consistentes (sin 'p_').
    search_term text,
    genre_name text,
    year_range text,
    country_name text,
    director_name text,
    actor_name text,
    media_type text,
    selection_code text,
    sort_by text,
    excluded_genres text[],
    excluded_countries text[],
    page_limit integer,
    page_offset integer
)
RETURNS TABLE(
    id bigint, title text, year integer, year_end text, type text, genres text,
    directors text, actors text, country text, country_code text, minutes integer,
    image text, fa_id text, fa_rating real, fa_votes integer, imdb_id text,
    imdb_rating real, imdb_votes integer, synopsis text, thumbhash_st text,
    critic text, last_synced_at timestamptz, episodes integer, wikipedia text,
    total_count bigint
)
LANGUAGE sql STABLE PARALLEL SAFE AS $function$
WITH filtered_movies AS (
    SELECT
        m.id,
        COUNT(*) OVER() AS total_count_unpaginated
    FROM
        public.movies m
    WHERE
        (search_term IS NULL OR search_term = '' OR m.title_norm ILIKE '%' || public.unaccent_immutable(lower(search_term)) || '%')
        AND (year_range IS NULL OR (year_range LIKE '%-%' AND (m.year <= (split_part(year_range, '-', 2)::int) AND ((split_part(year_range, '-', 1)::int) = 1926 OR m.year >= (split_part(year_range, '-', 1)::int))) OR (year_range NOT LIKE '%-%' AND m.year = year_range::int)))
        AND (media_type IS NULL OR media_type = 'all' OR (media_type = 'movies' AND (m.type IS NULL OR m.type IN ('D', 'A'))) OR (media_type = 'series' AND m.type ILIKE 'S%'))
        AND (country_name IS NULL OR m.country_id = (SELECT c.id FROM public.countries c WHERE c.name = country_name))
        AND (genre_name IS NULL OR m.genres_list ILIKE '%' || genre_name || '%')
        AND (director_name IS NULL OR m.directors_list ILIKE '%' || director_name || '%')
        AND (actor_name IS NULL OR m.actors_list ILIKE '%' || actor_name || '%')
        AND (selection_code IS NULL OR EXISTS (SELECT 1 FROM public.movie_collections mc JOIN public.collections coll ON mc.collection_id = coll.id WHERE mc.movie_id = m.id AND coll.code = selection_code))
        AND (excluded_genres IS NULL OR NOT m.genres_list ILIKE ANY (SELECT '%' || g || '%' FROM unnest(excluded_genres) as g))
        AND (excluded_countries IS NULL OR array_length(excluded_countries, 1) IS NULL OR m.country_id NOT IN (SELECT c.id FROM public.countries c WHERE c.name = ANY(excluded_countries)))
    ORDER BY
        CASE WHEN split_part(sort_by, ',', 1) = 'relevance' OR COALESCE(TRIM(sort_by), '') = '' THEN m.relevance END ASC,
        CASE WHEN split_part(sort_by, ',', 1) = 'year' AND split_part(sort_by, ',', 2) = 'desc' THEN m.year END DESC,
        CASE WHEN split_part(sort_by, ',', 1) = 'year' AND split_part(sort_by, ',', 2) = 'asc' THEN m.year END ASC,
        CASE WHEN split_part(sort_by, ',', 1) = 'fa_rating' AND split_part(sort_by, ',', 2) = 'desc' THEN m.fa_rating END DESC NULLS LAST,
        CASE WHEN split_part(sort_by, ',', 1) = 'imdb_rating' AND split_part(sort_by, ',', 2) = 'desc' THEN m.imdb_rating END DESC NULLS LAST,
        CASE WHEN split_part(sort_by, ',', 1) = 'fa_votes' AND split_part(sort_by, ',', 2) = 'desc' THEN m.fa_votes END DESC NULLS LAST,
        CASE WHEN split_part(sort_by, ',', 1) = 'imdb_votes' AND split_part(sort_by, ',', 2) = 'desc' THEN m.imdb_votes END DESC NULLS LAST,
        m.id ASC
)
SELECT
    m.id, m.title, m.year, m.year_end, m.type, m.genres_list AS genres,
    m.directors_list AS directors, m.actors_list AS actors, c.name AS country,
    c.code AS country_code, m.minutes, m.image, m.fa_id, m.fa_rating, m.fa_votes,
    m.imdb_id, m.imdb_rating, m.imdb_votes, m.synopsis, m.thumbhash_st, m.critic,
    m.last_synced_at, m.episodes, m.wikipedia, fm.total_count_unpaginated as total_count
FROM
    filtered_movies fm
JOIN public.movies m ON fm.id = m.id
LEFT JOIN public.countries c ON m.country_id = c.id
ORDER BY
    CASE WHEN split_part(sort_by, ',', 1) = 'relevance' OR COALESCE(TRIM(sort_by), '') = '' THEN m.relevance END ASC,
    CASE WHEN split_part(sort_by, ',', 1) = 'year' AND split_part(sort_by, ',', 2) = 'desc' THEN m.year END DESC,
    CASE WHEN split_part(sort_by, ',', 1) = 'year' AND split_part(sort_by, ',', 2) = 'asc' THEN m.year END ASC,
    CASE WHEN split_part(sort_by, ',', 1) = 'fa_rating' AND split_part(sort_by, ',', 2) = 'desc' THEN m.fa_rating END DESC NULLS LAST,
    CASE WHEN split_part(sort_by, ',', 1) = 'imdb_rating' AND split_part(sort_by, ',', 2) = 'desc' THEN m.imdb_rating END DESC NULLS LAST,
    CASE WHEN split_part(sort_by, ',', 1) = 'fa_votes' AND split_part(sort_by, ',', 2) = 'desc' THEN m.fa_votes END DESC NULLS LAST,
    CASE WHEN split_part(sort_by, ',', 1) = 'imdb_votes' AND split_part(sort_by, ',', 2) = 'desc' THEN m.imdb_votes END DESC NULLS LAST,
    m.id ASC
LIMIT page_limit
OFFSET page_offset;
$function$;

-- =================================================================
-- PASO 4: CREACIÓN DE TABLAS DE USUARIO Y TRIGGERS
-- =================================================================
-- Tabla para almacenar las valoraciones de los usuarios.
CREATE TABLE IF NOT EXISTS public.user_ratings (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    movie_id BIGINT NOT NULL REFERENCES public.movies(id) ON DELETE CASCADE,
    rating SMALLINT NOT NULL CHECK (rating >= 1 AND rating <= 10),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT user_ratings_user_movie_unique UNIQUE (user_id, movie_id)
);
CREATE INDEX IF NOT EXISTS user_ratings_user_id_idx ON public.user_ratings(user_id);
CREATE INDEX IF NOT EXISTS user_ratings_movie_id_idx ON public.user_ratings(movie_id);
-- Función de trigger para actualizar automáticamente el campo 'updated_at'.
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;
-- Trigger que se activa en cada actualización de la tabla user_ratings.
DROP TRIGGER IF EXISTS on_user_ratings_update ON public.user_ratings;
CREATE TRIGGER on_user_ratings_update
BEFORE UPDATE ON public.user_ratings
FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();

-- =================================================================
-- PASO 5: OPTIMIZACIÓN DE RENDIMIENTO (ÍNDICES)
-- =================================================================
-- Creamos un índice GIN (Generalized Inverted Index) sobre la columna normalizada.
-- Es el tipo de índice más eficiente para búsquedas con `ILIKE '%...%'` cuando se usa la extensión pg_trgm.
CREATE INDEX IF NOT EXISTS movies_title_norm_trgm_idx ON public.movies USING gin (title_norm gin_trgm_ops);
-- Índices para claves foráneas y campos de ordenación comunes.
CREATE INDEX IF NOT EXISTS movies_country_id_idx ON public.movies(country_id);
CREATE INDEX IF NOT EXISTS movies_year_idx ON public.movies(year DESC);
CREATE INDEX IF NOT EXISTS movies_fa_rating_idx ON public.movies(fa_rating DESC NULLS LAST);
CREATE INDEX IF NOT EXISTS movies_imdb_rating_idx ON public.movies(imdb_rating DESC NULLS LAST);
-- Índices para las tablas de relación.
CREATE INDEX IF NOT EXISTS movie_genres_movie_id_idx ON public.movie_genres(movie_id);
CREATE INDEX IF NOT EXISTS movie_genres_genre_id_idx ON public.movie_genres(genre_id);
CREATE INDEX IF NOT EXISTS movie_directors_movie_id_idx ON public.movie_directors(movie_id);
CREATE INDEX IF NOT EXISTS movie_directors_director_id_idx ON public.movie_directors(director_id);
CREATE INDEX IF NOT EXISTS movie_actors_movie_id_idx ON public.movie_actors(movie_id);
CREATE INDEX IF NOT EXISTS movie_actors_actor_id_idx ON public.movie_actors(actor_id);
CREATE INDEX IF NOT EXISTS movie_collections_movie_id_idx ON public.movie_collections(movie_id);
CREATE INDEX IF NOT EXISTS movie_collections_collection_id_idx ON public.movie_collections(collection_id);
-- Índices híbridos para las tablas de entidad (sugerencias).
CREATE INDEX IF NOT EXISTS directors_name_norm_prefix_idx ON public.directors (name_norm text_pattern_ops);
CREATE INDEX IF NOT EXISTS directors_name_norm_trgm_idx ON public.directors USING gin (name_norm gin_trgm_ops);
CREATE INDEX IF NOT EXISTS actors_name_norm_prefix_idx ON public.actors (name_norm text_pattern_ops);
CREATE INDEX IF NOT EXISTS actors_name_norm_trgm_idx ON public.actors USING gin (name_norm gin_trgm_ops);
CREATE INDEX IF NOT EXISTS countries_name_norm_prefix_idx ON public.countries (name_norm text_pattern_ops);
CREATE INDEX IF NOT EXISTS countries_name_norm_trgm_idx ON public.countries USING gin (name_norm gin_trgm_ops);
CREATE INDEX IF NOT EXISTS genres_name_norm_prefix_idx ON public.genres (name_norm text_pattern_ops);
CREATE INDEX IF NOT EXISTS genres_name_norm_trgm_idx ON public.genres USING gin (name_norm gin_trgm_ops);
-- Actualizamos las funciones de sugerencias para que usen la nueva arquitectura.
CREATE OR REPLACE FUNCTION public.get_actor_suggestions(search_term text)
RETURNS TABLE(suggestion text) LANGUAGE plpgsql STABLE PARALLEL SAFE AS $$
BEGIN
    RETURN QUERY
    SELECT a.name
    FROM public.actors a
    JOIN public.movie_actors ma ON a.id = ma.actor_id
    WHERE a.name_norm ILIKE '%' || public.unaccent_immutable(lower(search_term)) || '%'
    GROUP BY a.name
    ORDER BY COUNT(ma.movie_id) DESC
    LIMIT 10;
END;
$$;
CREATE OR REPLACE FUNCTION public.get_director_suggestions(search_term text)
RETURNS TABLE(suggestion text) LANGUAGE plpgsql STABLE PARALLEL SAFE AS $$
BEGIN
    RETURN QUERY
    SELECT d.name
    FROM public.directors d
    JOIN public.movie_directors md ON d.id = md.director_id
    WHERE d.name_norm ILIKE '%' || public.unaccent_immutable(lower(search_term)) || '%'
    GROUP BY d.name
    ORDER BY COUNT(md.movie_id) DESC
    LIMIT 10;
END;
$$;
CREATE OR REPLACE FUNCTION public.get_genre_suggestions(search_term text)
RETURNS TABLE(suggestion text) LANGUAGE sql STABLE PARALLEL SAFE AS $$
    SELECT name FROM public.genres
    WHERE similarity(name_norm, public.unaccent_immutable(lower(search_term))) > 0.2
    ORDER BY similarity(name_norm, public.unaccent_immutable(lower(search_term))) DESC
    LIMIT 5;
$$;
CREATE OR REPLACE FUNCTION public.get_country_suggestions(search_term text)
RETURNS TABLE(suggestion text) LANGUAGE sql STABLE PARALLEL SAFE AS $$
    SELECT name FROM public.countries
    WHERE similarity(name_norm, public.unaccent_immutable(lower(search_term))) > 0.2
    ORDER BY similarity(name_norm, public.unaccent_immutable(lower(search_term))) DESC
    LIMIT 5;
$$;

-- =================================================================
-- PASO 6: CONFIGURACIÓN DE SEGURIDAD (ROW LEVEL SECURITY)
-- =================================================================
-- Habilitamos RLS y definimos políticas de "solo lectura" para todas las tablas públicas.
DO $$
DECLARE
    t_name TEXT;
BEGIN
    FOR t_name IN 
        SELECT table_name FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name NOT LIKE 'pg_%' AND table_name NOT LIKE 'sql_%'
    LOOP
        EXECUTE format('ALTER TABLE public.%I ENABLE ROW LEVEL SECURITY;', t_name);
        EXECUTE format('DROP POLICY IF EXISTS "Enable read access for all users" ON public.%I;', t_name);
        EXECUTE format('CREATE POLICY "Enable read access for all users" ON public.%I FOR SELECT USING (true);', t_name);
    END LOOP;
END;
$$;
-- Definimos políticas específicas y más restrictivas para la tabla 'user_ratings'.
ALTER TABLE public.user_ratings ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS "Enable read access for all users" ON public.user_ratings; -- Quitamos la política pública genérica.
-- Los usuarios solo pueden ver, insertar, actualizar o borrar SUS PROPIAS valoraciones.
DROP POLICY IF EXISTS "Users can manage their own ratings" ON public.user_ratings;
CREATE POLICY "Users can manage their own ratings" ON public.user_ratings
FOR ALL
USING ( auth.uid() = user_id )
WITH CHECK ( auth.uid() = user_id );

-- =================================================================
-- PASO 7: FUNCIÓN DE INGESTA (ETL) CON DESNORMALIZACIÓN
-- =================================================================
-- v2.0: Añade una fase final de desnormalización para pre-calcular las listas
-- de géneros, directores y actores, optimizando drásticamente el rendimiento de lectura.
CREATE OR REPLACE FUNCTION public.process_staging_data()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    sync_timestamp TIMESTAMP WITH TIME ZONE := NOW();
    affected_movie_ids INT[];
BEGIN

    -- FASE 0: POBLAR TABLAS DE CATÁLOGO (SIN LÓGICA DE PAÍSES)
    -- ----------------------------------------------------------------
    -- Se asume que la tabla `countries` está pre-poblada y es la única fuente de verdad.
    -- Solo se pueblan los catálogos que pueden crecer dinámicamente (géneros, directores, actores).
    INSERT INTO public.genres (name)
    SELECT DISTINCT TRIM(g.name)
    FROM public.movies_staging, UNNEST(STRING_TO_ARRAY(genre, ',')) AS g(name)
    WHERE genre IS NOT NULL AND TRIM(g.name) <> ''
    ON CONFLICT (name) DO NOTHING;

    INSERT INTO public.directors (name)
    SELECT DISTINCT TRIM(d.name)
    FROM public.movies_staging, UNNEST(STRING_TO_ARRAY(directors, ',')) AS d(name)
    WHERE directors IS NOT NULL AND TRIM(d.name) <> ''
    ON CONFLICT (name) DO NOTHING;

    INSERT INTO public.actors (name)
    SELECT DISTINCT TRIM(a.name)
    FROM public.movies_staging, UNNEST(STRING_TO_ARRAY(actors, ',')) AS a(name)
    WHERE actors IS NOT NULL AND TRIM(a.name) <> '' AND actors <> '(A)'
    ON CONFLICT (name) DO NOTHING;

    -- FASE 1: UPSERT DE PELÍCULAS Y CAPTURA DE IDs AFECTADOS
    -- ----------------------------------------------------------------
    -- Se insertan o actualizan películas. La columna `country_id` se obtiene
    -- mediante un `LEFT JOIN` directo a la tabla `countries`.
    WITH upserted_movies AS (
        INSERT INTO public.movies (
            relevance, image, title, year, year_end, type, fa_rating, fa_votes, imdb_rating, imdb_votes,
            original_title, country_id, minutes, synopsis, fa_id, imdb_id, critic, last_synced_at,
            episodes, wikipedia
        )
        SELECT
            s.relevance, TRIM(s.image), s.title, public.to_integer_safe(s.year::TEXT),
            s.year_end, s.type, public.to_real_safe(s.fa_rating::TEXT), public.to_integer_safe(s.fa_votes::TEXT),
            public.to_real_safe(s.imdb_rating::TEXT), public.to_integer_safe(s.imdb_votes::TEXT),
            s.original_title,
            -- Aquí está la lógica clave: se une directamente por el nombre.
            -- Si no hay coincidencia, c.id será NULL.
            c.id,
            public.to_integer_safe(s.minutes::TEXT), s.synopsis, s.fa_id,
            s.imdb_id, s.critic, sync_timestamp,
            public.to_integer_safe(s.episodes::TEXT), TRIM(s.wikipedia)
        FROM public.movies_staging s
        LEFT JOIN public.countries c ON TRIM(s.country) = c.name
        WHERE s.image IS NOT NULL AND TRIM(s.image) <> ''
        ON CONFLICT (image) DO UPDATE SET
            relevance = EXCLUDED.relevance, title = EXCLUDED.title, year = EXCLUDED.year, year_end = EXCLUDED.year_end, type = EXCLUDED.type,
            fa_rating = EXCLUDED.fa_rating, fa_votes = EXCLUDED.fa_votes, imdb_rating = EXCLUDED.imdb_rating,
            imdb_votes = EXCLUDED.imdb_votes, original_title = EXCLUDED.original_title, country_id = EXCLUDED.country_id,
            minutes = EXCLUDED.minutes, synopsis = EXCLUDED.synopsis, fa_id = EXCLUDED.fa_id, imdb_id = EXCLUDED.imdb_id,
            critic = EXCLUDED.critic, last_synced_at = sync_timestamp,
            episodes = EXCLUDED.episodes, wikipedia = EXCLUDED.wikipedia
        RETURNING id
    )
    SELECT array_agg(id)
    INTO affected_movie_ids
    FROM upserted_movies;

    IF affected_movie_ids IS NULL THEN
        RAISE NOTICE 'No movies were inserted or updated. Exiting function.';
        RETURN;
    END IF;

    -- FASE 2: BORRADO DE RELACIONES ANTIGUAS
    -- ----------------------------------------------------------------
    -- Para las películas afectadas, se eliminan sus relaciones antiguas para
    -- asegurar que los nuevos datos de 'movies_staging' las reemplacen.
    DELETE FROM public.movie_genres WHERE movie_id = ANY(affected_movie_ids);
    DELETE FROM public.movie_directors WHERE movie_id = ANY(affected_movie_ids);
    DELETE FROM public.movie_actors WHERE movie_id = ANY(affected_movie_ids);
    DELETE FROM public.movie_collections WHERE movie_id = ANY(affected_movie_ids);

    -- FASE 3: RECONSTRUCCIÓN DE RELACIONES NUEVAS
    -- ----------------------------------------------------------------
    -- Se leen las relaciones de la tabla de staging y se insertan en las
    -- tablas de unión correspondientes (movie_genres, movie_directors, etc.).
    
    INSERT INTO public.movie_genres (movie_id, genre_id)
    SELECT m.id, g.id
    FROM public.movies_staging s
    JOIN public.movies m ON TRIM(s.image) = m.image
    CROSS JOIN LATERAL UNNEST(STRING_TO_ARRAY(s.genre, ',')) AS genre_name(name)
    JOIN public.genres g ON g.name = TRIM(genre_name.name)
    WHERE m.id = ANY(affected_movie_ids) ON CONFLICT DO NOTHING;

    INSERT INTO public.movie_directors (movie_id, director_id)
    SELECT m.id, d.id
    FROM public.movies_staging s
    JOIN public.movies m ON TRIM(s.image) = m.image
    CROSS JOIN LATERAL UNNEST(STRING_TO_ARRAY(REPLACE(s.directors, ', ', ','), ',')) AS director_name(name)
    JOIN public.directors d ON d.name = TRIM(director_name.name)
    WHERE m.id = ANY(affected_movie_ids) ON CONFLICT DO NOTHING;

    INSERT INTO public.movie_actors (movie_id, actor_id)
    SELECT m.id, a.id
    FROM public.movies_staging s
    JOIN public.movies m ON TRIM(s.image) = m.image
    CROSS JOIN LATERAL UNNEST(STRING_TO_ARRAY(REPLACE(s.actors, ', ', ','), ',')) AS actor_name(name)
    JOIN public.actors a ON a.name = TRIM(actor_name.name)
    WHERE m.id = ANY(affected_movie_ids) AND s.actors <> '(A)' ON CONFLICT DO NOTHING;

    INSERT INTO public.movie_collections (movie_id, collection_id)
    SELECT m.id, c.id
    FROM public.movies_staging s
    JOIN public.movies m ON TRIM(s.image) = m.image
    CROSS JOIN LATERAL UNNEST(STRING_TO_ARRAY(s.collection, ',')) AS collection_code(code)
    JOIN public.collections c ON c.code = TRIM(collection_code.code)
    WHERE m.id = ANY(affected_movie_ids) ON CONFLICT DO NOTHING;

    -- FASE 4: DESNORMALIZACIÓN (EL "MISE EN PLACE")
    -- ----------------------------------------------------------------
    -- Una vez que todas las relaciones están actualizadas, pre-calculamos
    -- las listas de texto. Este trabajo pesado se hace aquí, en tiempo de escritura,
    -- para que las lecturas del usuario sean ultrarrápidas.
    
    WITH aggregated_data AS (
        SELECT
            m.id,
            -- Usamos STRING_AGG para concatenar los nombres de las tablas relacionadas.
            -- El 'DISTINCT' previene duplicados y 'ORDER BY' asegura un orden consistente.
            STRING_AGG(DISTINCT g.name, ', ' ORDER BY g.name) AS genres,
            STRING_AGG(DISTINCT d.name, ', ' ORDER BY d.name) AS directors,
            STRING_AGG(DISTINCT a.name, ', ' ORDER BY a.name) AS actors
        FROM public.movies m
        -- Hacemos LEFT JOIN para asegurarnos de que se incluyan todas las películas.
        LEFT JOIN public.movie_genres mg ON m.id = mg.movie_id
        LEFT JOIN public.genres g ON mg.genre_id = g.id
        LEFT JOIN public.movie_directors md ON m.id = md.movie_id
        LEFT JOIN public.directors d ON md.director_id = d.id
        LEFT JOIN public.movie_actors ma ON m.id = ma.movie_id
        LEFT JOIN public.actors a ON ma.actor_id = a.id
        -- ¡CRÍTICO! Solo procesamos las películas que fueron afectadas en esta ejecución.
        WHERE m.id = ANY(affected_movie_ids)
        GROUP BY m.id
    )
    -- Ahora actualizamos la tabla 'movies' con los datos pre-calculados.
    UPDATE public.movies m
    SET
        genres_list = ad.genres,
        directors_list = ad.directors,
        actors_list = ad.actors
    FROM aggregated_data ad
    WHERE m.id = ad.id;
END;
$function$;
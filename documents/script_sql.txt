-- =================================================================
-- SCRIPT DE CONFIGURACIÓN COMPLETO PARA VIDEOCLUB.DIGITAL
-- =================================================================
-- Este script es idempotente y se puede ejecutar de forma segura. Orden de ejecución:
-- 1. Habilitación de Extensiones
-- 2. Creación de Funciones Auxiliares y modificaciones esquema/tabla
-- 3. Definición de la Lógica de Negocio (Función de búsqueda ultra-optimizada)
-- 4. Creación de Tablas de Usuario y Triggers
-- 5. Optimización de Rendimiento (Índices y Columnas Generadas)
-- 6. Configuración de Seguridad (Row Level Security)
-- 7. Función de Ingesta de Datos (ETL) con fase de Desnormalización
-- =================================================================

-- =================================================================
-- PASO 1: HABILITACIÓN DE EXTENSIONES
-- =================================================================
CREATE EXTENSION IF NOT EXISTS unaccent; -- Para búsquedas insensibles a acentos.
CREATE EXTENSION IF NOT EXISTS pg_trgm;  -- Para búsquedas por similitud y `ILIKE` rápido.

-- =================================================================
-- PASO 2: CREACIÓN DE FUNCIONES AUXILIARES Y DE UTILIDAD
-- MODIFICACIONES DE ESQUEMA Y ESTRUCTURA DE TABLAS
-- =================================================================
-- Función "wrapper" inmutable para `unaccent`, necesaria para crear índices funcionales.
CREATE OR REPLACE FUNCTION public.unaccent_immutable(text)
RETURNS text LANGUAGE sql IMMUTABLE PARALLEL SAFE AS
$$ SELECT public.unaccent('public.unaccent', $1); $$;
-- Función para convertir texto a INTEGER de forma segura, devolviendo NULL en caso de error.
CREATE OR REPLACE FUNCTION public.to_integer_safe(v_input TEXT)
RETURNS INTEGER LANGUAGE plpgsql IMMUTABLE PARALLEL SAFE AS $$
BEGIN RETURN v_input::INTEGER; EXCEPTION WHEN OTHERS THEN RETURN NULL; END; $$;
-- Función para convertir texto a REAL de forma segura, devolviendo NULL en caso de error.
CREATE OR REPLACE FUNCTION public.to_real_safe(v_input TEXT)
RETURNS REAL LANGUAGE plpgsql IMMUTABLE PARALLEL SAFE AS $$
BEGIN RETURN v_input::REAL; EXCEPTION WHEN OTHERS THEN RETURN NULL; END; $$;

-- =================================================================
-- 2.1. GARANTÍA DE COLUMNAS GENERADAS (Fix Crítico ETL)
-- =================================================================
-- Aseguramos que los vectores de búsqueda (_tsv) sean columnas generadas
-- y no simples DEFAULT. Esto garantiza que se actualicen automáticamente
-- cuando el ETL modifique las columnas de texto (_list).
-- Nota: Al recrearlas como STORED, Postgres recalculará los datos existentes.

ALTER TABLE public.movies DROP COLUMN IF EXISTS genres_tsv;
ALTER TABLE public.movies ADD COLUMN genres_tsv tsvector GENERATED ALWAYS AS (to_tsvector('spanish', public.unaccent_immutable(genres_list))) STORED;

ALTER TABLE public.movies DROP COLUMN IF EXISTS directors_tsv;
ALTER TABLE public.movies ADD COLUMN directors_tsv tsvector GENERATED ALWAYS AS (to_tsvector('simple', public.unaccent_immutable(directors_list))) STORED;

ALTER TABLE public.movies DROP COLUMN IF EXISTS actors_tsv;
ALTER TABLE public.movies ADD COLUMN actors_tsv tsvector GENERATED ALWAYS AS (to_tsvector('simple', public.unaccent_immutable(actors_list))) STORED;

ALTER TABLE public.movies DROP COLUMN IF EXISTS selections_tsv;
ALTER TABLE public.movies ADD COLUMN selections_tsv tsvector GENERATED ALWAYS AS (to_tsvector('simple', public.unaccent_immutable(selections_list))) STORED;

ALTER TABLE public.movies DROP COLUMN IF EXISTS studios_tsv;
ALTER TABLE public.movies ADD COLUMN studios_tsv tsvector GENERATED ALWAYS AS (to_tsvector('simple', public.unaccent_immutable(studios_list))) STORED;

-- 2.2. COLUMNA DE PROMEDIO CALCULADO (NUEVO)
-- Calcula automáticamente la nota media usando la lógica de negocio (+/- 0.3).
ALTER TABLE public.movies DROP COLUMN IF EXISTS avg_rating;
ALTER TABLE public.movies ADD COLUMN avg_rating real GENERATED ALWAYS AS (
    CASE
        WHEN (fa_rating IS NOT NULL AND fa_rating > 0) AND (imdb_rating IS NOT NULL AND imdb_rating > 0) THEN ((fa_rating + 0.3) + (imdb_rating - 0.3)) / 2.0
        WHEN (fa_rating IS NOT NULL AND fa_rating > 0) THEN fa_rating + 0.3
        WHEN (imdb_rating IS NOT NULL AND imdb_rating > 0) THEN imdb_rating - 0.3
        ELSE NULL
    END
) STORED;

-- =================================================================
-- FUNCIÓN DE BÚSQUEDA OPTIMIZADA (v3.0 - Smart Counting)
-- =================================================================
CREATE OR REPLACE FUNCTION public.search_movies_offset(
    search_term text,
    genre_name text,
    p_year_start integer,
    p_year_end integer,
    country_name text,
    director_name text,
    actor_name text,
    media_type text,
    p_selection_code text,
    p_studio_code text,
    excluded_genres text[],
    excluded_countries text[],
    sort_field text,
    sort_direction text,
    page_limit integer,
    page_offset integer,
    get_count boolean DEFAULT true -- NUEVO PARÁMETRO
)
RETURNS json
LANGUAGE plpgsql STABLE PARALLEL SAFE AS $function$
DECLARE
    v_query TEXT;
    v_order_clause TEXT;
    v_count_cte TEXT;
    v_count_select TEXT;
    v_json_result JSON;
    v_country_id INT;
    v_excluded_country_ids INT[];
    v_safe_sort_direction TEXT;
    v_safe_sort_field TEXT;
BEGIN
    -- FASE 1: VALIDACIÓN (Igual que antes)
    IF sort_direction IS NULL OR lower(sort_direction) NOT IN ('asc', 'desc') THEN
        v_safe_sort_direction := 'ASC';
    ELSE
        v_safe_sort_direction := upper(sort_direction);
    END IF;

    v_safe_sort_field := lower(coalesce(sort_field, 'relevance'));
    IF v_safe_sort_field NOT IN ('relevance', 'year', 'fa_rating', 'imdb_rating', 'fa_votes', 'imdb_votes', 'avg_rating') THEN
        v_safe_sort_field := 'relevance';
    END IF;

    v_order_clause := CASE v_safe_sort_field
        WHEN 'year' THEN format('ORDER BY m.year %s, m.relevance ASC', v_safe_sort_direction)
        WHEN 'fa_rating' THEN format('ORDER BY m.fa_rating %s NULLS LAST, m.relevance ASC', v_safe_sort_direction)
        WHEN 'imdb_rating' THEN format('ORDER BY m.imdb_rating %s NULLS LAST, m.relevance ASC', v_safe_sort_direction)
        WHEN 'fa_votes' THEN format('ORDER BY m.fa_votes %s NULLS LAST, m.relevance ASC', v_safe_sort_direction)
        WHEN 'imdb_votes' THEN format('ORDER BY m.imdb_votes %s NULLS LAST, m.relevance ASC', v_safe_sort_direction)
        WHEN 'avg_rating' THEN format('ORDER BY m.avg_rating %s NULLS LAST, m.relevance ASC', v_safe_sort_direction)
        ELSE 'ORDER BY m.relevance ASC'
    END;

    -- FASE 2: PRE-PROCESAMIENTO (Igual que antes)
    IF country_name IS NOT NULL AND country_name != '' THEN
        SELECT c.id INTO v_country_id FROM public.countries c WHERE c.name_norm = public.unaccent_immutable(lower(country_name)) LIMIT 1;
    END IF;
    IF excluded_countries IS NOT NULL AND array_length(excluded_countries, 1) > 0 THEN
        SELECT array_agg(c.id) INTO v_excluded_country_ids FROM public.countries c WHERE c.name_norm = ANY(
            SELECT public.unaccent_immutable(lower(x)) FROM unnest(excluded_countries) x
        );
    END IF;

    -- FASE 3: LÓGICA CONDICIONAL DE CONTEO (NUEVO)
    -- Si get_count es true, calculamos el total. Si no, devolvemos -1.
    IF get_count THEN
        v_count_cte := ', total AS (SELECT count(*) AS value FROM filtered_movies)';
        v_count_select := '(SELECT value FROM total)';
    ELSE
        v_count_cte := '';
        v_count_select := '-1';
    END IF;

    -- FASE 4: CONSTRUCCIÓN DE CONSULTA
    v_query := '
        WITH filtered_movies AS (
            SELECT m.id
            FROM public.movies m
            WHERE
                ($1 IS NULL OR $1 = '''' OR m.title_norm LIKE ''%'' || public.unaccent_immutable(lower($1)) || ''%'')
                AND ($2 IS NULL OR m.genres_tsv @@ plainto_tsquery(''spanish'', public.unaccent_immutable($2)))
                AND ($3 IS NULL OR m.year >= $3)
                AND ($4 IS NULL OR m.year <= $4)
                AND ($5 IS NULL OR m.country_id = $5)
                AND ($6 IS NULL OR m.directors_tsv @@ phraseto_tsquery(''simple'', public.unaccent_immutable($6)))
                AND ($7 IS NULL OR m.actors_tsv @@ phraseto_tsquery(''simple'', public.unaccent_immutable($7)))
                AND ($8 IS NULL OR $8 = ''all''
                     OR ($8 = ''movies'' AND (m.type IS NULL OR m.type IN (''D'', ''A'')))
                     OR ($8 = ''series'' AND m.type ILIKE ''S%''))
                AND ($9 IS NULL OR m.selections_tsv @@ plainto_tsquery(''simple'', $9))
                AND ($10 IS NULL OR m.studios_tsv @@ plainto_tsquery(''simple'', $10))
                AND ($11 IS NULL OR NOT m.genres_tsv @@ (
                    SELECT string_agg(plainto_tsquery(''spanish'', public.unaccent_immutable(g))::text, '' | '')::tsquery FROM unnest($11) g
                ))
                AND ($12 IS NULL OR NOT (m.country_id = ANY($12)))
        )' || v_count_cte || '
        SELECT json_build_object(
            ''total'', ' || v_count_select || ',
            ''items'', COALESCE(
                (
                    SELECT json_agg(rows)
                    FROM (
                        SELECT
                            m.id, m.title, 
                            -- Optimización: No enviar título original si es igual al título (ahorra bytes)
                            CASE WHEN lower(m.original_title) = lower(m.title) THEN NULL ELSE m.original_title END as original_title,
                            m.year, 
                            -- Optimización: Solo enviar datos de series si es una serie
                            CASE WHEN m.type ILIKE ''S%'' THEN m.year_end ELSE NULL END as year_end,
                            m.type, 
                            m.genres_list AS genres,
                            m.directors_list AS directors, 
                            m.actors_list AS actors, 
                            c.name AS country,
                            c.code AS country_code, 
                            m.minutes, m.image, m.fa_id, 
                            m.fa_rating, m.fa_votes,
                            m.imdb_id, m.imdb_rating, m.imdb_votes, 
                            m.avg_rating, -- Incluimos el promedio calculado
                            m.synopsis, m.thumbhash_st, m.critic,
                            -- Optimización: Enviar timestamp como entero (segundos) en lugar de string ISO
                            EXTRACT(EPOCH FROM m.last_synced_at)::INT as last_synced_at,
                            -- Optimización: Solo enviar episodios si es serie
                            CASE WHEN m.type ILIKE ''S%'' THEN m.episodes ELSE NULL END as episodes,
                            m.wikipedia, 
                            m.selections_list, m.studios_list, m.justwatch
                        FROM filtered_movies fm
                        JOIN public.movies m ON fm.id = m.id
                        LEFT JOIN public.countries c ON m.country_id = c.id
                        ' || v_order_clause || '
                        LIMIT $13
                        OFFSET $14
                    ) as rows
                ),
                ''[]''::json
            )
        );
    ';
    
    -- FASE 5: EJECUCIÓN
    EXECUTE v_query
    INTO v_json_result
    USING
        search_term, genre_name, p_year_start, p_year_end, v_country_id, -- $1..$5
        director_name, actor_name, media_type, p_selection_code, p_studio_code, -- $6..$10
        excluded_genres, v_excluded_country_ids, page_limit, page_offset; -- $11..$14
        
    RETURN v_json_result;
END;
$function$;

-- =================================================================
-- PASO 4: REFACTORIZACIÓN DE TABLAS DE USUARIO Y TRIGGERS
-- =================================================================

-- 4.1. Limpieza de estructuras obsoletas.
-- Asegura que las tablas y tipos antiguos sean eliminados antes de crear los nuevos.
DROP TABLE IF EXISTS public.user_ratings;
DROP TABLE IF EXISTS public.user_movie_lists;
DROP TYPE IF EXISTS public.user_list_type;

-- 4.2. Creación de la nueva tabla consolidada 'user_movie_entries'.
CREATE TABLE IF NOT EXISTS public.user_movie_entries (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    movie_id BIGINT NOT NULL REFERENCES public.movies(id) ON DELETE CASCADE,
    
    on_watchlist BOOLEAN DEFAULT false,
    rating SMALLINT CHECK (rating >= 1 AND rating <= 10),
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),

    CONSTRAINT user_movie_entry_unique UNIQUE (user_id, movie_id)
);

-- 4.3. Creación de índices para optimizar el rendimiento.
CREATE INDEX IF NOT EXISTS user_movie_entries_movie_id_idx ON public.user_movie_entries(movie_id);

-- 4.4. Función de trigger y trigger para 'updated_at'.
-- Esta función se reutiliza para la nueva tabla.
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS on_user_movie_entries_update ON public.user_movie_entries;
CREATE TRIGGER on_user_movie_entries_update
BEFORE UPDATE ON public.user_movie_entries
FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();

-- =================================================================
-- PASO 5: OPTIMIZACIÓN DE RENDIMIENTO (ÍNDICES)
-- =================================================================
-- Índice GIN (Generalized Inverted Index) sobre la columna normalizada.
-- Es el tipo de índice más eficiente para búsquedas con `ILIKE '%...%'` cuando se usa la extensión pg_trgm.
CREATE INDEX IF NOT EXISTS movies_title_norm_trgm_idx ON public.movies USING gin (title_norm gin_trgm_ops);
-- Índice único para la columna image, necesario para la cláusula ON CONFLICT (image) en la función de carga.
CREATE UNIQUE INDEX IF NOT EXISTS movies_image_unique_idx ON public.movies(image);
-- Para claves foráneas y campos de ordenación comunes.
CREATE INDEX IF NOT EXISTS movies_year_idx ON public.movies(year DESC);
CREATE INDEX IF NOT EXISTS movies_fa_rating_idx ON public.movies(fa_rating DESC NULLS LAST);
CREATE INDEX IF NOT EXISTS movies_imdb_rating_idx ON public.movies(imdb_rating DESC NULLS LAST);
-- Para las tablas de relación.
CREATE INDEX IF NOT EXISTS movie_genres_genre_id_idx ON public.movie_genres(genre_id);
CREATE INDEX IF NOT EXISTS movie_directors_director_id_idx ON public.movie_directors(director_id);
CREATE INDEX IF NOT EXISTS movie_actors_actor_id_idx ON public.movie_actors(actor_id);
CREATE INDEX IF NOT EXISTS movie_selections_selection_id_idx ON public.movie_selections(selection_id);
CREATE INDEX IF NOT EXISTS movie_studios_studio_id_idx ON public.movie_studios(studio_id);
-- Para tablas de entidad (sugerencias). Solo índices GIN (pg_trgm) pq las búsquedas son substring ('%texto%'), donde los índices B-Tree (prefix) no tienen efecto.
CREATE INDEX IF NOT EXISTS directors_name_norm_trgm_idx ON public.directors USING gin (name_norm gin_trgm_ops);
CREATE INDEX IF NOT EXISTS actors_name_norm_trgm_idx ON public.actors USING gin (name_norm gin_trgm_ops);
CREATE INDEX IF NOT EXISTS countries_name_norm_trgm_idx ON public.countries USING gin (name_norm gin_trgm_ops);
CREATE INDEX IF NOT EXISTS genres_name_norm_trgm_idx ON public.genres USING gin (name_norm gin_trgm_ops);
-- Índices GIN sobre las nuevas columnas
CREATE INDEX IF NOT EXISTS movies_genres_tsv_idx ON public.movies USING GIN(genres_tsv);
CREATE INDEX IF NOT EXISTS movies_directors_tsv_idx ON public.movies USING GIN(directors_tsv);
CREATE INDEX IF NOT EXISTS movies_actors_tsv_idx ON public.movies USING GIN(actors_tsv);
CREATE INDEX IF NOT EXISTS movies_selections_tsv_idx ON public.movies USING GIN(selections_tsv);
CREATE INDEX IF NOT EXISTS movies_studios_tsv_idx ON public.movies USING GIN(studios_tsv);
-- El índice de relevancia es vital porque es el orden por defecto.
CREATE INDEX IF NOT EXISTS movies_relevance_idx ON public.movies(relevance ASC);
-- Para ordenación por votos (que también usas en el selector)
CREATE INDEX IF NOT EXISTS movies_fa_votes_idx ON public.movies(fa_votes DESC NULLS LAST);
CREATE INDEX IF NOT EXISTS movies_imdb_votes_idx ON public.movies(imdb_votes DESC NULLS LAST);
-- Índice compuesto para optimizar el filtrado por tipo + ordenación (muy común)
CREATE INDEX IF NOT EXISTS movies_type_relevance_idx ON public.movies(type, relevance ASC);
-- Índices compuesto para combinaciones de filtros común: País + Año, sólo Series, sólo Películas
CREATE INDEX IF NOT EXISTS movies_country_id_year_desc_idx ON public.movies(country_id, year DESC);
CREATE INDEX IF NOT EXISTS movies_only_movies_year_desc_idx ON public.movies(year DESC) 
WHERE type IS NULL OR type IN ('D', 'A');
CREATE INDEX IF NOT EXISTS movies_only_series_year_desc_idx 
ON public.movies(year DESC) 
WHERE lower(type::text) LIKE 's%';
-- ▼▼▼ NUEVOS ÍNDICES DE RENDIMIENTO (Fix "Tirones en Países") ▼▼▼
CREATE INDEX IF NOT EXISTS movies_country_relevance_idx ON public.movies(country_id, relevance ASC);
CREATE INDEX IF NOT EXISTS movies_country_fa_votes_idx ON public.movies(country_id, fa_votes DESC NULLS LAST);
CREATE INDEX IF NOT EXISTS movies_country_imdb_votes_idx ON public.movies(country_id, imdb_votes DESC NULLS LAST);
CREATE INDEX IF NOT EXISTS movies_country_fa_rating_idx ON public.movies(country_id, fa_rating DESC NULLS LAST);
CREATE INDEX IF NOT EXISTS movies_country_imdb_rating_idx ON public.movies(country_id, imdb_rating DESC NULLS LAST);
-- Índice para el nuevo promedio
CREATE INDEX IF NOT EXISTS movies_avg_rating_idx ON public.movies(avg_rating DESC NULLS LAST);

-- ▼▼▼ OPTIMIZACIÓN FILTROS COMBINADOS (v2) ▼▼▼
-- Índice compuesto para País + Tipo + Año (Cubre "Películas de España", "Series de EEUU", etc.)
-- NOTA: No usamos 'WHERE type IS NOT NULL' para incluir películas clásicas (type=NULL)
CREATE INDEX IF NOT EXISTS movies_country_type_year_idx ON public.movies(country_id, type, year DESC);

-- Índice auxiliar para Studios + Tipo (Optimizado para búsquedas específicas de plataformas)
CREATE INDEX IF NOT EXISTS movies_studios_type_idx ON public.movies USING GIN(studios_tsv) WHERE type IS NOT NULL;

ANALYZE public.movies;

-- Actualizamos las funciones de sugerencias para que usen la nueva arquitectura.
-- OPTIMIZACIÓN: Pasamos a LANGUAGE SQL para permitir inlining y reducir overhead.

-- =================================================================
-- VISTAS MATERIALIZADAS PARA SUGERENCIAS (Optimización)
-- =================================================================

-- 1. Actores
DROP MATERIALIZED VIEW IF EXISTS mv_actor_suggestions CASCADE;
CREATE MATERIALIZED VIEW mv_actor_suggestions AS
SELECT a.id, a.name, a.name_norm, COUNT(ma.movie_id) AS movie_count
FROM public.actors a LEFT JOIN public.movie_actors ma ON a.id = ma.actor_id
GROUP BY a.id, a.name, a.name_norm;

CREATE UNIQUE INDEX mv_actor_suggestions_id_idx ON mv_actor_suggestions(id);
CREATE INDEX mv_actor_suggestions_name_norm_trgm_idx ON mv_actor_suggestions USING gin(name_norm gin_trgm_ops);
CREATE INDEX mv_actor_suggestions_count_idx ON mv_actor_suggestions(movie_count DESC);

-- 2. Directores
DROP MATERIALIZED VIEW IF EXISTS mv_director_suggestions CASCADE;
CREATE MATERIALIZED VIEW mv_director_suggestions AS
SELECT d.id, d.name, d.name_norm, COUNT(md.movie_id) AS movie_count
FROM public.directors d LEFT JOIN public.movie_directors md ON d.id = md.director_id
GROUP BY d.id, d.name, d.name_norm;

CREATE UNIQUE INDEX mv_director_suggestions_id_idx ON mv_director_suggestions(id);
CREATE INDEX mv_director_suggestions_name_norm_trgm_idx ON mv_director_suggestions USING gin(name_norm gin_trgm_ops);
CREATE INDEX mv_director_suggestions_count_idx ON mv_director_suggestions(movie_count DESC);

-- 3. Títulos (Optimización para Autocompletado)
DROP MATERIALIZED VIEW IF EXISTS mv_title_suggestions CASCADE;
CREATE MATERIALIZED VIEW mv_title_suggestions AS
SELECT title, title_norm, min(relevance) as best_relevance
FROM public.movies
GROUP BY title, title_norm;

CREATE UNIQUE INDEX mv_title_suggestions_title_idx ON mv_title_suggestions(title);
CREATE INDEX mv_title_suggestions_title_norm_trgm_idx ON mv_title_suggestions USING gin(title_norm gin_trgm_ops);
CREATE INDEX mv_title_suggestions_relevance_idx ON mv_title_suggestions(best_relevance ASC);

-- 3. Funciones de Lectura
CREATE OR REPLACE FUNCTION public.get_actor_suggestions(search_term text)
RETURNS TABLE(suggestion text) LANGUAGE sql STABLE PARALLEL SAFE AS $$
    SELECT name FROM mv_actor_suggestions
    WHERE name_norm ILIKE '%' || public.unaccent_immutable(lower(search_term)) || '%'
    ORDER BY movie_count DESC
    LIMIT 10;
$$;

CREATE OR REPLACE FUNCTION public.get_director_suggestions(search_term text)
RETURNS TABLE(suggestion text) LANGUAGE sql STABLE PARALLEL SAFE AS $$
    SELECT name FROM mv_director_suggestions
    WHERE name_norm ILIKE '%' || public.unaccent_immutable(lower(search_term)) || '%'
    ORDER BY movie_count DESC
    LIMIT 10;
$$;

CREATE OR REPLACE FUNCTION public.get_title_suggestions(search_term text)
RETURNS TABLE(suggestion text) LANGUAGE sql STABLE PARALLEL SAFE AS $$
    SELECT title FROM mv_title_suggestions
    WHERE title_norm ILIKE '%' || public.unaccent_immutable(lower(search_term)) || '%'
    ORDER BY best_relevance ASC
    LIMIT 10;
$$;

CREATE OR REPLACE FUNCTION public.get_genre_suggestions(search_term text)
RETURNS TABLE(suggestion text) LANGUAGE sql STABLE PARALLEL SAFE AS $$
    SELECT name FROM public.genres
    WHERE similarity(name_norm, public.unaccent_immutable(lower(search_term))) > 0.2
    ORDER BY similarity(name_norm, public.unaccent_immutable(lower(search_term))) DESC
    LIMIT 5;
$$;

CREATE OR REPLACE FUNCTION public.get_country_suggestions(search_term text)
RETURNS TABLE(suggestion text) LANGUAGE sql STABLE PARALLEL SAFE AS $$
    SELECT name FROM public.countries
    WHERE similarity(name_norm, public.unaccent_immutable(lower(search_term))) > 0.2
    ORDER BY similarity(name_norm, public.unaccent_immutable(lower(search_term))) DESC
    LIMIT 5;
$$;

-- =================================================================
-- FUNCIONES PARA FILTROS DINÁMICOS (TOP 100 ALEATORIO)
-- =================================================================

CREATE OR REPLACE FUNCTION public.get_random_top_actors(limit_count int DEFAULT 5)
RETURNS TABLE(name text) LANGUAGE sql VOLATILE PARALLEL SAFE AS $$
    WITH top_actors AS (
        SELECT name
        FROM mv_actor_suggestions
        ORDER BY movie_count DESC
        LIMIT 100
    )
    SELECT name FROM top_actors ORDER BY random() LIMIT limit_count;
$$;

CREATE OR REPLACE FUNCTION public.get_random_top_directors(limit_count int DEFAULT 5)
RETURNS TABLE(name text) LANGUAGE sql VOLATILE PARALLEL SAFE AS $$
    WITH top_directors AS (
        SELECT name
        FROM mv_director_suggestions
        ORDER BY movie_count DESC
        LIMIT 100
    )
    SELECT name FROM top_directors ORDER BY random() LIMIT limit_count;
$$;

-- =================================================================
-- PASO 6: CONFIGURACIÓN DE SEGURIDAD (ROW LEVEL SECURITY)
-- =================================================================

-- 6.1. Habilitamos RLS y políticas de solo lectura para tablas públicas.
DO $$ DECLARE t_name TEXT; BEGIN
    FOR t_name IN SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name NOT IN ('user_movie_entries', 'movies_staging') AND table_name NOT LIKE 'pg_%' AND table_name NOT LIKE 'sql_%'
    LOOP
        EXECUTE format('ALTER TABLE public.%I ENABLE ROW LEVEL SECURITY;', t_name);
        EXECUTE format('DROP POLICY IF EXISTS "Enable read access for all users" ON public.%I;', t_name);
        EXECUTE format('CREATE POLICY "Enable read access for all users" ON public.%I FOR SELECT USING (true);', t_name);
    END LOOP;
END; $$;

-- 6.2. Políticas de seguridad específicas para la nueva tabla 'user_movie_entries'.
ALTER TABLE public.user_movie_entries ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Los usuarios pueden gestionar sus propias entradas" ON public.user_movie_entries;
DROP POLICY IF EXISTS "Los usuarios pueden leer sus propias entradas" ON public.user_movie_entries;
DROP POLICY IF EXISTS "Enable read access for all users" ON public.user_movie_entries; -- SEGURIDAD CRÍTICA: Eliminar política global si existe por error

CREATE POLICY "Los usuarios pueden leer sus propias entradas"
ON public.user_movie_entries FOR SELECT
USING ( auth.uid() = user_id );

CREATE POLICY "Los usuarios pueden gestionar sus propias entradas"
ON public.user_movie_entries FOR ALL -- (INSERT, UPDATE, DELETE)
USING ( auth.uid() = user_id )
WITH CHECK ( auth.uid() = user_id );

-- =================================================================
-- PASO 7: FUNCIÓN DE INGESTA (ETL) CON DENORMALIZACIÓN (v2.1 - Corregida para Columnas Generadas)
-- =================================================================
-- v2.1: Se simplifica drásticamente la FASE 4. La función ahora solo se
-- encarga de actualizar las columnas de texto `_list`. Las columnas `_tsv`
-- son ahora `GENERATED COLUMNS` en la propia tabla, por lo que PostgreSQL
-- las actualiza automáticamente cada vez que las columnas `_list` cambian.
-- Esto elimina el error "cannot update a generated column".
CREATE OR REPLACE FUNCTION public.process_staging_data()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    sync_timestamp TIMESTAMP WITH TIME ZONE := NOW();
    affected_movie_ids INT[];
BEGIN
    -- FASE 0, 1, 2 y 3 (SIN CAMBIOS)
    -- ... (El código de inserción en catálogos, upsert de películas y reconstrucción de relaciones es correcto y no cambia)
    -- (Asegúrate de tener las fases 0 a 3 aquí como estaban antes)

    -- FASE 0: POBLAR TABLAS DE CATÁLOGO (SIN LÓGICA DE PAÍSES)
    INSERT INTO public.genres (name)
    SELECT DISTINCT TRIM(g.name) FROM public.movies_staging, UNNEST(STRING_TO_ARRAY(genre, ',')) AS g(name)
    WHERE genre IS NOT NULL AND TRIM(g.name) <> '' ON CONFLICT (name) DO NOTHING;

    INSERT INTO public.directors (name)
    SELECT DISTINCT TRIM(d.name) FROM public.movies_staging, UNNEST(STRING_TO_ARRAY(directors, ',')) AS d(name)
    WHERE directors IS NOT NULL AND TRIM(d.name) <> '' ON CONFLICT (name) DO NOTHING;

    INSERT INTO public.actors (name)
    SELECT DISTINCT TRIM(a.name) FROM public.movies_staging, UNNEST(STRING_TO_ARRAY(actors, ',')) AS a(name)
    WHERE actors IS NOT NULL AND TRIM(a.name) <> '' AND actors <> '(A)' ON CONFLICT (name) DO NOTHING;
    
    -- Poblar Selections (si no existen, usando el código como nombre temporalmente)
    INSERT INTO public.selections (code, name)
    SELECT DISTINCT TRIM(s.code), TRIM(s.code) FROM public.movies_staging, UNNEST(STRING_TO_ARRAY(collection, ',')) AS s(code)
    WHERE collection IS NOT NULL AND TRIM(s.code) <> '' ON CONFLICT (code) DO NOTHING;

    -- Poblar Studios (si no existen, usando el código como nombre temporalmente)
    INSERT INTO public.studios (code, name)
    SELECT DISTINCT TRIM(s.code), TRIM(s.code) FROM public.movies_staging, UNNEST(STRING_TO_ARRAY(studio, ',')) AS s(code)
    WHERE studio IS NOT NULL AND TRIM(s.code) <> '' ON CONFLICT (name) DO NOTHING;

    -- FASE 1: UPSERT DE PELÍCULAS Y CAPTURA DE IDs AFECTADOS
    WITH upserted_movies AS (
        INSERT INTO public.movies (
            relevance, image, title, year, year_end, type, fa_rating, fa_votes, imdb_rating, imdb_votes,
            original_title, country_id, minutes, synopsis, fa_id, imdb_id, critic, last_synced_at, episodes, wikipedia, justwatch
        )
        SELECT
            s.relevance, TRIM(s.image), s.title, public.to_integer_safe(s.year::TEXT),
            s.year_end, s.type, public.to_real_safe(s.fa_rating::TEXT), public.to_integer_safe(s.fa_votes::TEXT),
            public.to_real_safe(s.imdb_rating::TEXT), public.to_integer_safe(s.imdb_votes::TEXT),
            s.original_title, c.id, public.to_integer_safe(s.minutes::TEXT), s.synopsis, s.fa_id,
            s.imdb_id, s.critic, sync_timestamp, public.to_integer_safe(s.episodes::TEXT), TRIM(s.wikipedia), TRIM(s.justwatch)
        FROM public.movies_staging s
        LEFT JOIN public.countries c ON TRIM(s.country) = c.name
        WHERE s.image IS NOT NULL AND TRIM(s.image) <> ''
        ON CONFLICT (image) DO UPDATE SET
            relevance = EXCLUDED.relevance, title = EXCLUDED.title, year = EXCLUDED.year, year_end = EXCLUDED.year_end, type = EXCLUDED.type,
            fa_rating = EXCLUDED.fa_rating, fa_votes = EXCLUDED.fa_votes, imdb_rating = EXCLUDED.imdb_rating, imdb_votes = EXCLUDED.imdb_votes,
            original_title = EXCLUDED.original_title, country_id = EXCLUDED.country_id, minutes = EXCLUDED.minutes, synopsis = EXCLUDED.synopsis,
            fa_id = EXCLUDED.fa_id, imdb_id = EXCLUDED.imdb_id, critic = EXCLUDED.critic, last_synced_at = sync_timestamp,
            episodes = EXCLUDED.episodes, wikipedia = EXCLUDED.wikipedia, justwatch = EXCLUDED.justwatch
        RETURNING id
    )
    SELECT array_agg(id) INTO affected_movie_ids FROM upserted_movies;

    IF affected_movie_ids IS NULL THEN
        RAISE NOTICE 'No movies were inserted or updated. Exiting function.';
        RETURN;
    END IF;

    -- FASE 2: BORRADO DE RELACIONES ANTIGUAS
    DELETE FROM public.movie_genres WHERE movie_id = ANY(affected_movie_ids);
    DELETE FROM public.movie_directors WHERE movie_id = ANY(affected_movie_ids);
    DELETE FROM public.movie_actors WHERE movie_id = ANY(affected_movie_ids);
    DELETE FROM public.movie_selections WHERE movie_id = ANY(affected_movie_ids);
    DELETE FROM public.movie_studios WHERE movie_id = ANY(affected_movie_ids);

    -- FASE 3: RECONSTRUCCIÓN DE RELACIONES NUEVAS
    INSERT INTO public.movie_genres (movie_id, genre_id)
    SELECT m.id, g.id FROM public.movies_staging s JOIN public.movies m ON TRIM(s.image) = m.image
    CROSS JOIN LATERAL UNNEST(STRING_TO_ARRAY(s.genre, ',')) AS genre_name(name) JOIN public.genres g ON g.name = TRIM(genre_name.name)
    WHERE m.id = ANY(affected_movie_ids) ON CONFLICT DO NOTHING;

    INSERT INTO public.movie_directors (movie_id, director_id)
    SELECT m.id, d.id FROM public.movies_staging s JOIN public.movies m ON TRIM(s.image) = m.image
    CROSS JOIN LATERAL UNNEST(STRING_TO_ARRAY(REPLACE(s.directors, ', ', ','), ',')) AS director_name(name) JOIN public.directors d ON d.name = TRIM(director_name.name)
    WHERE m.id = ANY(affected_movie_ids) ON CONFLICT (movie_id, director_id) DO NOTHING;

    INSERT INTO public.movie_actors (movie_id, actor_id, ordinality)
    SELECT DISTINCT ON (m.id, a.id) m.id, a.id, actor_name.ordinality FROM public.movies_staging s
    JOIN public.movies m ON TRIM(s.image) = m.image
    CROSS JOIN LATERAL UNNEST(STRING_TO_ARRAY(REPLACE(s.actors, ', ', ','), ',')) WITH ORDINALITY AS actor_name(name, ordinality) JOIN public.actors a ON a.name = TRIM(actor_name.name)
    WHERE m.id = ANY(affected_movie_ids) AND s.actors <> '(A)'
    ORDER BY m.id, a.id, actor_name.ordinality ASC ON CONFLICT (movie_id, actor_id) DO UPDATE SET ordinality = EXCLUDED.ordinality;

    INSERT INTO public.movie_selections (movie_id, selection_id)
    SELECT m.id, c.id FROM public.movies_staging s JOIN public.movies m ON TRIM(s.image) = m.image
    CROSS JOIN LATERAL UNNEST(STRING_TO_ARRAY(s.collection, ',')) AS sel_code(code) JOIN public.selections c ON c.code = TRIM(sel_code.code)
    WHERE m.id = ANY(affected_movie_ids) ON CONFLICT (movie_id, selection_id) DO NOTHING;

    INSERT INTO public.movie_studios (movie_id, studio_id)
    SELECT m.id, st.id FROM public.movies_staging s JOIN public.movies m ON TRIM(s.image) = m.image
    CROSS JOIN LATERAL UNNEST(STRING_TO_ARRAY(s.studio, ',')) AS stu_code(code) JOIN public.studios st ON st.code = TRIM(stu_code.code)
    WHERE m.id = ANY(affected_movie_ids) ON CONFLICT (movie_id, studio_id) DO NOTHING;

    -- ==========================================================
    --  ▼▼▼ FASE 4: DESNORMALIZACIÓN (SIMPLIFICADA) ▼▼▼
    -- ==========================================================
    WITH aggregated_data AS (
        SELECT
            m.id,
            STRING_AGG(DISTINCT g.name, ', ' ORDER BY g.name) AS genres,
            STRING_AGG(DISTINCT d.name, ', ' ORDER BY d.name) AS directors,
            STRING_AGG(DISTINCT sel.code, ',') AS selections,
            STRING_AGG(DISTINCT stu.code, ',') AS studios,
            (
                SELECT STRING_AGG(actor_name, ', ' ORDER BY ordinality)
                FROM (
                    SELECT DISTINCT ON (a.name) a.name as actor_name, ma.ordinality
                    FROM public.movie_actors ma
                    JOIN public.actors a ON ma.actor_id = a.id
                    WHERE ma.movie_id = m.id
                    ORDER BY a.name, ma.ordinality
                ) AS unique_actors
            ) AS actors
        FROM public.movies m
        LEFT JOIN public.movie_genres mg ON m.id = mg.movie_id
        LEFT JOIN public.genres g ON mg.genre_id = g.id
        LEFT JOIN public.movie_directors md ON m.id = md.movie_id
        LEFT JOIN public.directors d ON md.director_id = d.id
        LEFT JOIN public.movie_selections ms ON m.id = ms.movie_id
        LEFT JOIN public.selections sel ON ms.selection_id = sel.id
        LEFT JOIN public.movie_studios mst ON m.id = mst.movie_id
        LEFT JOIN public.studios stu ON mst.studio_id = stu.id
        WHERE m.id = ANY(affected_movie_ids)
        GROUP BY m.id
    )
    -- Ahora, solo actualizamos las columnas de texto `_list`.
    -- La base de datos se encargará de actualizar las columnas `_tsv` automáticamente.
    UPDATE public.movies m
    SET
        genres_list = ad.genres,
        directors_list = ad.directors,
        actors_list = ad.actors,
        selections_list = ad.selections,
        studios_list = ad.studios
    FROM aggregated_data ad
    WHERE m.id = ad.id;

    -- FASE 5: REFRESCO DE VISTAS MATERIALIZADAS
    -- Se usa CONCURRENTLY para no bloquear lecturas durante la actualización.
    -- Requiere índices únicos creados en el paso 5.
    REFRESH MATERIALIZED VIEW CONCURRENTLY mv_actor_suggestions;
    REFRESH MATERIALIZED VIEW CONCURRENTLY mv_director_suggestions;
    REFRESH MATERIALIZED VIEW CONCURRENTLY mv_title_suggestions;

    -- FASE 6: ACTUALIZACIÓN DE ESTADÍSTICAS
    -- Crítico para que el planificador use los índices correctamente tras la carga masiva.
    ANALYZE public.movies;

END;
$function$;
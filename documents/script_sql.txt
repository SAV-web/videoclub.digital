-- =================================================================
-- SCRIPT DE CONFIGURACIÓN COMPLETO PARA VIDEOCLUB.DIGITAL
-- =================================================================
-- Este script es idempotente y se puede ejecutar de forma segura. Orden de ejecución:
-- 1. Habilitación de Extensiones
-- 2. Creación de Funciones Auxiliares y modificaciones esquema/tabla
-- 3. Definición de la Lógica de Negocio (Función de búsqueda ultra-optimizada)
-- 4. Creación de Tablas de Usuario y Triggers
-- 5. Optimización de Rendimiento (Índices y Columnas Generadas)
-- 6. Configuración de Seguridad (Row Level Security)
-- 7. Función de Ingesta de Datos (ETL) con fase de Desnormalización
-- =================================================================

-- =================================================================
-- PASO 1: HABILITACIÓN DE EXTENSIONES
-- =================================================================
CREATE EXTENSION IF NOT EXISTS unaccent; -- Para búsquedas insensibles a acentos.
CREATE EXTENSION IF NOT EXISTS pg_trgm;  -- Para búsquedas por similitud y `ILIKE` rápido.

-- =================================================================
-- PASO 2: CREACIÓN DE FUNCIONES AUXILIARES Y DE UTILIDAD
-- MODIFICACIONES DE ESQUEMA Y ESTRUCTURA DE TABLAS
-- =================================================================
-- Función "wrapper" inmutable para `unaccent`, necesaria para crear índices funcionales.
CREATE OR REPLACE FUNCTION public.unaccent_immutable(text)
RETURNS text LANGUAGE sql IMMUTABLE PARALLEL SAFE AS
$$ SELECT public.unaccent('public.unaccent', $1); $$;
-- Función para convertir texto a INTEGER de forma segura, devolviendo NULL en caso de error.
CREATE OR REPLACE FUNCTION public.to_integer_safe(v_input TEXT)
RETURNS INTEGER LANGUAGE plpgsql IMMUTABLE PARALLEL SAFE AS $$
BEGIN RETURN v_input::INTEGER; EXCEPTION WHEN OTHERS THEN RETURN NULL; END; $$;
-- Función para convertir texto a REAL de forma segura, devolviendo NULL en caso de error.
CREATE OR REPLACE FUNCTION public.to_real_safe(v_input TEXT)
RETURNS REAL LANGUAGE plpgsql IMMUTABLE PARALLEL SAFE AS $$
BEGIN RETURN v_input::REAL; EXCEPTION WHEN OTHERS THEN RETURN NULL; END; $$;

-- =================================================================
-- FUNCIÓN DE BÚSQUEDA OPTIMIZADA (v2.1 - plpgsql)
-- =================================================================
-- Principales cambios:
-- 1. Conversión de SQL a PL/pgSQL para permitir lógica procedural.
-- 2. Pre-cálculo del ID del país para eliminar la subconsulta en el WHERE.
--    Esto mejora el rendimiento al reducir la carga por fila en la consulta principal.
-- =================================================================
CREATE OR REPLACE FUNCTION public.search_movies_offset(
    search_term text,
    genre_name text,
    p_year_start integer,
    p_year_end integer,
    country_name text,
    director_name text,
    actor_name text,
    media_type text,
    selection_code text,
    excluded_genres text[],
    excluded_countries text[],
    sort_field text,
    sort_direction text,
    page_limit integer,
    page_offset integer
)
RETURNS json
LANGUAGE plpgsql STABLE PARALLEL SAFE AS $function$
DECLARE
    -- Variables para IDs resueltos (solo los que realmente necesitas)
    v_country_id INT;
BEGIN
    -- ============================================================
    -- FASE 1: PRE-PROCESAMIENTO (Resolución de IDs)
    -- ============================================================
    -- Solo resolvemos el país porque es un JOIN simple y frecuente
    IF country_name IS NOT NULL AND country_name != '' THEN
        SELECT id INTO v_country_id 
        FROM public.countries 
        WHERE name = country_name;
        
        -- Opcional: Validación
        IF v_country_id IS NULL THEN
            RAISE NOTICE 'País "%" no encontrado, ignorando filtro', country_name;
            -- Puedes decidir si retornas vacío o continúas sin el filtro
        END IF;
    END IF;
    
    -- ============================================================
    -- FASE 2: CONSULTA PRINCIPAL (Con ID Pre-resuelto)
    -- ============================================================
    RETURN (
        WITH filtered_movies AS (
            SELECT
                m.id,
                m.relevance, m.year, m.fa_rating, m.imdb_rating, 
                m.fa_votes, m.imdb_votes
            FROM public.movies m
            WHERE
                -- Búsqueda de texto (CRÍTICO: Cambiar a FTS como propuse antes)
                -- ✅ MEJORA: Usar el índice GIN/trgm para búsquedas de texto. Es más rápido que ILIKE.
                (search_term IS NULL OR search_term = '' OR m.title_norm % public.unaccent_immutable(lower(search_term)))
                
                -- Filtros numéricos simples (PostgreSQL los optimiza perfectamente)
                AND (p_year_start IS NULL OR m.year >= p_year_start)
                AND (p_year_end IS NULL OR m.year <= p_year_end)
                
                -- Tipo de medio (condición compuesta pero simple)
                AND (media_type IS NULL OR media_type = 'all' 
                     OR (media_type = 'movies' AND (m.type IS NULL OR m.type IN ('D', 'A'))) 
                     OR (media_type = 'series' AND m.type ILIKE 'S%'))
                
                -- ✅ País: Ahora usa el ID pre-resuelto
                AND (v_country_id IS NULL OR m.country_id = v_country_id)
                
                -- ✅ Género, Director, Actor: MANTENER subconsultas con tsvector
                -- Son búsquedas de texto sobre columnas indexadas con GIN, no lookups simples
                AND (genre_name IS NULL OR m.genres_tsv @@ plainto_tsquery('spanish', genre_name))
                AND (director_name IS NULL OR m.directors_tsv @@ plainto_tsquery('spanish', director_name))
                AND (actor_name IS NULL OR m.actors_tsv @@ plainto_tsquery('spanish', actor_name))
                
                -- Colecciones (búsqueda simple en lista)
                AND (selection_code IS NULL OR m.collections_list ILIKE '%' || selection_code || '%')
                
                -- Exclusiones (arrays)
                AND (excluded_genres IS NULL OR 
                     NOT m.genres_list ILIKE ANY (SELECT '%' || g || '%' FROM unnest(excluded_genres) as g))
                AND (excluded_countries IS NULL OR array_length(excluded_countries, 1) IS NULL OR 
                     m.country_id NOT IN (SELECT c.id FROM public.countries c WHERE c.name = ANY(excluded_countries)))
        ),
        paginated_ids AS (
            SELECT id
            FROM filtered_movies
            ORDER BY
                 CASE WHEN sort_field = 'relevance' THEN relevance END ASC,
                 CASE WHEN sort_field = 'year' AND sort_direction = 'asc' THEN year END ASC,
                 CASE WHEN sort_field = 'year' AND sort_direction = 'desc' THEN year END DESC,
                 CASE WHEN sort_field = 'fa_rating' AND sort_direction = 'asc' THEN fa_rating END ASC NULLS LAST,
                 CASE WHEN sort_field = 'fa_rating' AND sort_direction = 'desc' THEN fa_rating END DESC NULLS LAST,
                 CASE WHEN sort_field = 'imdb_rating' AND sort_direction = 'asc' THEN imdb_rating END ASC NULLS LAST,
                 CASE WHEN sort_field = 'imdb_rating' AND sort_direction = 'desc' THEN imdb_rating END DESC NULLS LAST,
                 relevance ASC
            LIMIT page_limit
            OFFSET page_offset
        ),
        total AS (
            SELECT count(*) as value FROM filtered_movies
        )
        SELECT json_build_object(
            'total', (SELECT value FROM total),
            'items', (
                SELECT COALESCE(json_agg(rows), '[]'::json)
                FROM (
                    SELECT
                        m.id, m.title, m.year, m.year_end, m.type, 
                        m.genres_list AS genres,
                        m.directors_list AS directors, 
                        m.actors_list AS actors, 
                        c.name AS country,
                        c.code AS country_code, 
                        m.minutes, m.image, m.fa_id, 
                        m.fa_rating, m.fa_votes,
                        m.imdb_id, m.imdb_rating, m.imdb_votes, 
                        m.synopsis, m.thumbhash_st, m.critic,
                        m.last_synced_at, m.episodes, m.wikipedia, 
                        m.collections_list
                    FROM paginated_ids pi
                    JOIN public.movies m ON pi.id = m.id
                    LEFT JOIN public.countries c ON m.country_id = c.id
                ) as rows
            )
        )
    );
END;
$function$;

-- =================================================================
-- PASO 4: REFACTORIZACIÓN DE TABLAS DE USUARIO Y TRIGGERS
-- =================================================================

-- 4.1. Limpieza de estructuras obsoletas.
-- Asegura que las tablas y tipos antiguos sean eliminados antes de crear los nuevos.
DROP TABLE IF EXISTS public.user_ratings;
DROP TABLE IF EXISTS public.user_movie_lists;
DROP TYPE IF EXISTS public.user_list_type;

-- 4.2. Creación de la nueva tabla consolidada 'user_movie_entries'.
CREATE TABLE IF NOT EXISTS public.user_movie_entries (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    movie_id BIGINT NOT NULL REFERENCES public.movies(id) ON DELETE CASCADE,
    
    on_watchlist BOOLEAN DEFAULT false,
    rating SMALLINT CHECK (rating >= 1 AND rating <= 10),
    
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),

    CONSTRAINT user_movie_entry_unique UNIQUE (user_id, movie_id)
);

-- 4.3. Creación de índices para optimizar el rendimiento.
CREATE INDEX IF NOT EXISTS user_movie_entries_user_id_idx ON public.user_movie_entries(user_id);
CREATE INDEX IF NOT EXISTS user_movie_entries_movie_id_idx ON public.user_movie_entries(movie_id);

-- 4.4. Función de trigger y trigger para 'updated_at'.
-- Esta función se reutiliza para la nueva tabla.
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS on_user_movie_entries_update ON public.user_movie_entries;
CREATE TRIGGER on_user_movie_entries_update
BEFORE UPDATE ON public.user_movie_entries
FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();

-- =================================================================
-- PASO 5: OPTIMIZACIÓN DE RENDIMIENTO (ÍNDICES)
-- =================================================================
-- Creamos un índice GIN (Generalized Inverted Index) sobre la columna normalizada.
-- Es el tipo de índice más eficiente para búsquedas con `ILIKE '%...%'` cuando se usa la extensión pg_trgm.
CREATE INDEX IF NOT EXISTS movies_title_norm_trgm_idx ON public.movies USING gin (title_norm gin_trgm_ops);
-- Índices para claves foráneas y campos de ordenación comunes.
CREATE INDEX IF NOT EXISTS movies_country_id_idx ON public.movies(country_id);
CREATE INDEX IF NOT EXISTS movies_year_idx ON public.movies(year DESC);
CREATE INDEX IF NOT EXISTS movies_fa_rating_idx ON public.movies(fa_rating DESC NULLS LAST);
CREATE INDEX IF NOT EXISTS movies_imdb_rating_idx ON public.movies(imdb_rating DESC NULLS LAST);
-- Índices para las tablas de relación.
CREATE INDEX IF NOT EXISTS movie_genres_movie_id_idx ON public.movie_genres(movie_id);
CREATE INDEX IF NOT EXISTS movie_genres_genre_id_idx ON public.movie_genres(genre_id);
CREATE INDEX IF NOT EXISTS movie_directors_movie_id_idx ON public.movie_directors(movie_id);
CREATE INDEX IF NOT EXISTS movie_directors_director_id_idx ON public.movie_directors(director_id);
CREATE INDEX IF NOT EXISTS movie_actors_movie_id_idx ON public.movie_actors(movie_id);
CREATE INDEX IF NOT EXISTS movie_actors_actor_id_idx ON public.movie_actors(actor_id);
CREATE INDEX IF NOT EXISTS movie_collections_movie_id_idx ON public.movie_collections(movie_id);
CREATE INDEX IF NOT EXISTS movie_collections_collection_id_idx ON public.movie_collections(collection_id);
-- Índice para guardar el orden de los actores y su índice.
CREATE INDEX IF NOT EXISTS movie_actors_ordinality_idx ON public.movie_actors(ordinality);
-- Índices híbridos para las tablas de entidad (sugerencias).
CREATE INDEX IF NOT EXISTS directors_name_norm_prefix_idx ON public.directors (name_norm text_pattern_ops);
CREATE INDEX IF NOT EXISTS directors_name_norm_trgm_idx ON public.directors USING gin (name_norm gin_trgm_ops);
CREATE INDEX IF NOT EXISTS actors_name_norm_prefix_idx ON public.actors (name_norm text_pattern_ops);
CREATE INDEX IF NOT EXISTS actors_name_norm_trgm_idx ON public.actors USING gin (name_norm gin_trgm_ops);
CREATE INDEX IF NOT EXISTS countries_name_norm_prefix_idx ON public.countries (name_norm text_pattern_ops);
CREATE INDEX IF NOT EXISTS countries_name_norm_trgm_idx ON public.countries USING gin (name_norm gin_trgm_ops);
CREATE INDEX IF NOT EXISTS genres_name_norm_prefix_idx ON public.genres (name_norm text_pattern_ops);
CREATE INDEX IF NOT EXISTS genres_name_norm_trgm_idx ON public.genres USING gin (name_norm gin_trgm_ops);
-- Índices GIN sobre las nuevas columnas
CREATE INDEX IF NOT EXISTS movies_genres_tsv_idx ON public.movies USING GIN(genres_tsv);
CREATE INDEX IF NOT EXISTS movies_directors_tsv_idx ON public.movies USING GIN(directors_tsv);
CREATE INDEX IF NOT EXISTS movies_actors_tsv_idx ON public.movies USING GIN(actors_tsv);
-- Índices compuesto para combinaciones de filtros común: País + Año, sólo Series, sólo Películas
CREATE INDEX IF NOT EXISTS movies_country_id_year_desc_idx 
ON public.movies(country_id, year DESC);
CREATE INDEX IF NOT EXISTS movies_only_movies_year_desc_idx 
ON public.movies(year DESC) 
WHERE type IS NULL OR type IN ('D', 'A');
CREATE INDEX IF NOT EXISTS movies_only_series_year_desc_idx 
ON public.movies(year DESC) 
WHERE lower(type::text) LIKE 's%';
-- Actualizamos las funciones de sugerencias para que usen la nueva arquitectura.
CREATE OR REPLACE FUNCTION public.get_actor_suggestions(search_term text)
RETURNS TABLE(suggestion text) LANGUAGE plpgsql STABLE PARALLEL SAFE AS $$
BEGIN
    RETURN QUERY
    SELECT a.name
    FROM public.actors a
    JOIN public.movie_actors ma ON a.id = ma.actor_id
    WHERE a.name_norm ILIKE '%' || public.unaccent_immutable(lower(search_term)) || '%'
    GROUP BY a.name
    ORDER BY COUNT(ma.movie_id) DESC
    LIMIT 10;
END;
$$;
CREATE OR REPLACE FUNCTION public.get_director_suggestions(search_term text)
RETURNS TABLE(suggestion text) LANGUAGE plpgsql STABLE PARALLEL SAFE AS $$
BEGIN
    RETURN QUERY
    SELECT d.name
    FROM public.directors d
    JOIN public.movie_directors md ON d.id = md.director_id
    WHERE d.name_norm ILIKE '%' || public.unaccent_immutable(lower(search_term)) || '%'
    GROUP BY d.name
    ORDER BY COUNT(md.movie_id) DESC
    LIMIT 10;
END;
$$;
CREATE OR REPLACE FUNCTION public.get_genre_suggestions(search_term text)
RETURNS TABLE(suggestion text) LANGUAGE sql STABLE PARALLEL SAFE AS $$
    SELECT name FROM public.genres
    WHERE similarity(name_norm, public.unaccent_immutable(lower(search_term))) > 0.2
    ORDER BY similarity(name_norm, public.unaccent_immutable(lower(search_term))) DESC
    LIMIT 5;
$$;
CREATE OR REPLACE FUNCTION public.get_country_suggestions(search_term text)
RETURNS TABLE(suggestion text) LANGUAGE sql STABLE PARALLEL SAFE AS $$
    SELECT name FROM public.countries
    WHERE similarity(name_norm, public.unaccent_immutable(lower(search_term))) > 0.2
    ORDER BY similarity(name_norm, public.unaccent_immutable(lower(search_term))) DESC
    LIMIT 5;
$$;

-- =================================================================
-- PASO 6: CONFIGURACIÓN DE SEGURIDAD (ROW LEVEL SECURITY)
-- =================================================================

-- 6.1. Habilitamos RLS y políticas de solo lectura para tablas públicas.
DO $$ DECLARE t_name TEXT; BEGIN
    FOR t_name IN SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name NOT IN ('user_movie_entries') AND table_name NOT LIKE 'pg_%' AND table_name NOT LIKE 'sql_%'
    LOOP
        EXECUTE format('ALTER TABLE public.%I ENABLE ROW LEVEL SECURITY;', t_name);
        EXECUTE format('DROP POLICY IF EXISTS "Enable read access for all users" ON public.%I;', t_name);
        EXECUTE format('CREATE POLICY "Enable read access for all users" ON public.%I FOR SELECT USING (true);', t_name);
    END LOOP;
END; $$;

-- 6.2. Políticas de seguridad específicas para la nueva tabla 'user_movie_entries'.
ALTER TABLE public.user_movie_entries ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Los usuarios pueden gestionar sus propias entradas" ON public.user_movie_entries;
DROP POLICY IF EXISTS "Los usuarios pueden leer sus propias entradas" ON public.user_movie_entries;

CREATE POLICY "Los usuarios pueden leer sus propias entradas"
ON public.user_movie_entries FOR SELECT
USING ( auth.uid() = user_id );

CREATE POLICY "Los usuarios pueden gestionar sus propias entradas"
ON public.user_movie_entries FOR ALL -- (INSERT, UPDATE, DELETE)
USING ( auth.uid() = user_id )
WITH CHECK ( auth.uid() = user_id );

-- =================================================================
-- PASO 7: FUNCIÓN DE INGESTA (ETL) CON DESNORMALIZACIÓN
-- =================================================================
-- v2.0: Añade una fase final de desnormalización para pre-calcular las listas
-- de géneros, directores y actores, optimizando drásticamente el rendimiento de lectura.
CREATE OR REPLACE FUNCTION public.process_staging_data()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    sync_timestamp TIMESTAMP WITH TIME ZONE := NOW();
    affected_movie_ids INT[];
BEGIN

    -- FASE 0: POBLAR TABLAS DE CATÁLOGO (SIN LÓGICA DE PAÍSES)
    -- ----------------------------------------------------------------
    -- Se asume que la tabla `countries` está pre-poblada y es la única fuente de verdad.
    -- Solo se pueblan los catálogos que pueden crecer dinámicamente (géneros, directores, actores).
    INSERT INTO public.genres (name)
    SELECT DISTINCT TRIM(g.name)
    FROM public.movies_staging, UNNEST(STRING_TO_ARRAY(genre, ',')) AS g(name)
    WHERE genre IS NOT NULL AND TRIM(g.name) <> ''
    ON CONFLICT (name) DO NOTHING;

    INSERT INTO public.directors (name)
    SELECT DISTINCT TRIM(d.name)
    FROM public.movies_staging, UNNEST(STRING_TO_ARRAY(directors, ',')) AS d(name)
    WHERE directors IS NOT NULL AND TRIM(d.name) <> ''
    ON CONFLICT (name) DO NOTHING;

    INSERT INTO public.actors (name)
    SELECT DISTINCT TRIM(a.name)
    FROM public.movies_staging, UNNEST(STRING_TO_ARRAY(actors, ',')) AS a(name)
    WHERE actors IS NOT NULL AND TRIM(a.name) <> '' AND actors <> '(A)'
    ON CONFLICT (name) DO NOTHING;

    -- FASE 1: UPSERT DE PELÍCULAS Y CAPTURA DE IDs AFECTADOS
    -- ----------------------------------------------------------------
    -- Se insertan o actualizan películas. La columna `country_id` se obtiene
    -- mediante un `LEFT JOIN` directo a la tabla `countries`.
    WITH upserted_movies AS (
        INSERT INTO public.movies (
            relevance, image, title, year, year_end, type, fa_rating, fa_votes, imdb_rating, imdb_votes,
            original_title, country_id, minutes, synopsis, fa_id, imdb_id, critic, last_synced_at,
            episodes, wikipedia
        )
        SELECT
            s.relevance, TRIM(s.image), s.title, public.to_integer_safe(s.year::TEXT),
            s.year_end, s.type, public.to_real_safe(s.fa_rating::TEXT), public.to_integer_safe(s.fa_votes::TEXT),
            public.to_real_safe(s.imdb_rating::TEXT), public.to_integer_safe(s.imdb_votes::TEXT),
            s.original_title,
            -- Aquí está la lógica clave: se une directamente por el nombre.
            -- Si no hay coincidencia, c.id será NULL.
            c.id,
            public.to_integer_safe(s.minutes::TEXT), s.synopsis, s.fa_id,
            s.imdb_id, s.critic, sync_timestamp,
            public.to_integer_safe(s.episodes::TEXT), TRIM(s.wikipedia)
        FROM public.movies_staging s
        LEFT JOIN public.countries c ON TRIM(s.country) = c.name
        WHERE s.image IS NOT NULL AND TRIM(s.image) <> ''
        ON CONFLICT (image) DO UPDATE SET
            relevance = EXCLUDED.relevance, title = EXCLUDED.title, year = EXCLUDED.year, year_end = EXCLUDED.year_end, type = EXCLUDED.type,
            fa_rating = EXCLUDED.fa_rating, fa_votes = EXCLUDED.fa_votes, imdb_rating = EXCLUDED.imdb_rating,
            imdb_votes = EXCLUDED.imdb_votes, original_title = EXCLUDED.original_title, country_id = EXCLUDED.country_id,
            minutes = EXCLUDED.minutes, synopsis = EXCLUDED.synopsis, fa_id = EXCLUDED.fa_id, imdb_id = EXCLUDED.imdb_id,
            critic = EXCLUDED.critic, last_synced_at = sync_timestamp,
            episodes = EXCLUDED.episodes, wikipedia = EXCLUDED.wikipedia
        RETURNING id
    )
    SELECT array_agg(id)
    INTO affected_movie_ids
    FROM upserted_movies;

    IF affected_movie_ids IS NULL THEN
        RAISE NOTICE 'No movies were inserted or updated. Exiting function.';
        RETURN;
    END IF;

    -- FASE 2: BORRADO DE RELACIONES ANTIGUAS
    -- ----------------------------------------------------------------
    -- Para las películas afectadas, se eliminan sus relaciones antiguas para
    -- asegurar que los nuevos datos de 'movies_staging' las reemplacen.
    DELETE FROM public.movie_genres WHERE movie_id = ANY(affected_movie_ids);
    DELETE FROM public.movie_directors WHERE movie_id = ANY(affected_movie_ids);
    DELETE FROM public.movie_actors WHERE movie_id = ANY(affected_movie_ids);
    DELETE FROM public.movie_collections WHERE movie_id = ANY(affected_movie_ids);

    -- FASE 3: RECONSTRUCCIÓN DE RELACIONES NUEVAS
    -- ----------------------------------------------------------------
    -- Se leen las relaciones de la tabla de staging y se insertan en las
    -- tablas de unión correspondientes (movie_genres, movie_directors, etc.).
    
    INSERT INTO public.movie_genres (movie_id, genre_id)
    SELECT m.id, g.id
    FROM public.movies_staging s
    JOIN public.movies m ON TRIM(s.image) = m.image
    CROSS JOIN LATERAL UNNEST(STRING_TO_ARRAY(s.genre, ',')) AS genre_name(name)
    JOIN public.genres g ON g.name = TRIM(genre_name.name)
    WHERE m.id = ANY(affected_movie_ids) ON CONFLICT DO NOTHING;

    INSERT INTO public.movie_directors (movie_id, director_id)
    SELECT m.id, d.id
    FROM public.movies_staging s
    JOIN public.movies m ON TRIM(s.image) = m.image
    CROSS JOIN LATERAL UNNEST(STRING_TO_ARRAY(REPLACE(s.directors, ', ', ','), ',')) AS director_name(name)
    JOIN public.directors d ON d.name = TRIM(director_name.name)
    WHERE m.id = ANY(affected_movie_ids) ON CONFLICT (movie_id, director_id) DO NOTHING;

    INSERT INTO public.movie_actors (movie_id, actor_id, ordinality)
    -- Usamos DISTINCT ON para asegurarnos de que solo insertamos la primera aparición de cada actor por película,
    -- evitando así el error "cannot affect row a second time" si un actor está duplicado en la cadena de texto.
    SELECT DISTINCT ON (m.id, a.id) m.id, a.id, actor_name.ordinality
    FROM public.movies_staging s
    JOIN public.movies m ON TRIM(s.image) = m.image
    CROSS JOIN LATERAL UNNEST(STRING_TO_ARRAY(REPLACE(s.actors, ', ', ','), ',')) WITH ORDINALITY AS actor_name(name, ordinality)
    JOIN public.actors a ON a.name = TRIM(actor_name.name)
    WHERE m.id = ANY(affected_movie_ids) AND s.actors <> '(A)'
    ORDER BY m.id, a.id, actor_name.ordinality ASC ON CONFLICT (movie_id, actor_id) DO UPDATE SET ordinality = EXCLUDED.ordinality;

    INSERT INTO public.movie_collections (movie_id, collection_id)
    SELECT m.id, c.id
    FROM public.movies_staging s
    JOIN public.movies m ON TRIM(s.image) = m.image
    CROSS JOIN LATERAL UNNEST(STRING_TO_ARRAY(s.collection, ',')) AS collection_code(code)
    JOIN public.collections c ON c.code = TRIM(collection_code.code)
    WHERE m.id = ANY(affected_movie_ids) ON CONFLICT (movie_id, collection_id) DO NOTHING;

    -- FASE 4: DESNORMALIZACIÓN (EL "MISE EN PLACE")
    -- ----------------------------------------------------------------
    -- Una vez que todas las relaciones están actualizadas, pre-calculamos
    -- las listas de texto. Este trabajo pesado se hace aquí, en tiempo de escritura,
    -- para que las lecturas del usuario sean ultrarrápidas.
    
    WITH aggregated_data AS (
        SELECT
            m.id,
            -- Usamos STRING_AGG para concatenar los nombres de las tablas relacionadas.
            STRING_AGG(DISTINCT g.name, ', ' ORDER BY g.name) AS genres,
            STRING_AGG(DISTINCT d.name, ', ' ORDER BY d.name) AS directors,
            STRING_AGG(DISTINCT c.code, ',') AS collections, -- Agregamos los códigos de colección
            -- ==========================================================
            (
                -- Subconsulta para obtener actores únicos ordenados por su aparición original.
                -- Esto evita la duplicación causada por los JOINs con géneros/directores.
                SELECT STRING_AGG(actor_name, ', ' ORDER BY ordinality)
                FROM (
                    SELECT DISTINCT ON (a.name) a.name as actor_name, ma.ordinality
                    FROM public.movie_actors ma
                    JOIN public.actors a ON ma.actor_id = a.id
                    WHERE ma.movie_id = m.id
                    ORDER BY a.name, ma.ordinality
                ) AS unique_actors
            ) AS actors
        FROM public.movies m
        -- Hacemos LEFT JOIN para asegurarnos de que se incluyan todas las películas.
        LEFT JOIN public.movie_genres mg ON m.id = mg.movie_id
        LEFT JOIN public.genres g ON mg.genre_id = g.id
        LEFT JOIN public.movie_directors md ON m.id = md.movie_id
        LEFT JOIN public.directors d ON md.director_id = d.id
        LEFT JOIN public.movie_collections mc ON m.id = mc.movie_id
        LEFT JOIN public.collections c ON mc.collection_id = c.id
        WHERE m.id = ANY(affected_movie_ids)
        GROUP BY m.id
    )
    -- Ahora actualizamos la tabla 'movies' con los datos pre-calculados.
    UPDATE public.movies m
    SET
        genres_list = ad.genres,
        directors_list = ad.directors,
        actors_list = ad.actors,
        collections_list = ad.collections
    FROM aggregated_data ad
    WHERE m.id = ad.id;
END;
$function$;